{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["file:///D:/printx/redmoo/node_modules/%40mysten/sui/node_modules/%40mysten/bcs/src/b58.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { base58 } from '@scure/base';\n\nexport const toBase58 = (buffer: Uint8Array) => base58.encode(buffer);\nexport const fromBase58 = (str: string) => base58.decode(str);\n\n/** @deprecated use toBase58 instead */\nexport const toB58 = toBase58;\n\n/** @deprecated use fromBase58 instead */\nexport const fromB58 = fromBase58;\n"],"names":[],"mappings":";;;;;;AAGA,SAAS,cAAc;;AAEhB,MAAM,WAAW,CAAC,4JAAuB,SAAA,CAAO,MAAA,CAAO,MAAM;AAC7D,MAAM,aAAa,CAAC,yJAAgB,SAAA,CAAO,MAAA,CAAO,GAAG;AAGrD,MAAM,QAAQ;AAGd,MAAM,UAAU","debugId":null}},
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["file:///D:/printx/redmoo/node_modules/%40mysten/sui/node_modules/%40mysten/bcs/src/b64.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromBase64(base64String: string): Uint8Array {\n\treturn Uint8Array.from(atob(base64String), (char) => char.charCodeAt(0));\n}\n\nconst CHUNK_SIZE = 8192;\nexport function toBase64(bytes: Uint8Array): string {\n\t// Special-case the simple case for speed's sake.\n\tif (bytes.length < CHUNK_SIZE) {\n\t\treturn btoa(String.fromCharCode(...bytes));\n\t}\n\n\tlet output = '';\n\tfor (var i = 0; i < bytes.length; i += CHUNK_SIZE) {\n\t\tconst chunk = bytes.slice(i, i + CHUNK_SIZE);\n\t\toutput += String.fromCharCode(...chunk);\n\t}\n\n\treturn btoa(output);\n}\n\n/** @deprecated use toBase64 instead */\nexport const toB64 = toBase64;\n\n/** @deprecated use fromBase64 instead */\nexport const fromB64 = fromBase64;\n"],"names":[],"mappings":";;;;;;AAGO,SAAS,WAAW,YAAA,EAAkC;IAC5D,OAAO,WAAW,IAAA,CAAK,KAAK,YAAY,GAAG,CAAC,OAAS,KAAK,UAAA,CAAW,CAAC,CAAC;AACxE;AAEA,MAAM,aAAa;AACZ,SAAS,SAAS,KAAA,EAA2B;IAEnD,IAAI,MAAM,MAAA,GAAS,YAAY;QAC9B,OAAO,KAAK,OAAO,YAAA,CAAa,GAAG,KAAK,CAAC;IAC1C;IAEA,IAAI,SAAS;IACb,IAAA,IAAS,IAAI,GAAG,IAAI,MAAM,MAAA,EAAQ,KAAK,WAAY;QAClD,MAAM,QAAQ,MAAM,KAAA,CAAM,GAAG,IAAI,UAAU;QAC3C,UAAU,OAAO,YAAA,CAAa,GAAG,KAAK;IACvC;IAEA,OAAO,KAAK,MAAM;AACnB;AAGO,MAAM,QAAQ;AAGd,MAAM,UAAU","debugId":null}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///D:/printx/redmoo/node_modules/%40mysten/sui/node_modules/%40mysten/bcs/src/hex.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromHex(hexStr: string): Uint8Array {\n\tconst normalized = hexStr.startsWith('0x') ? hexStr.slice(2) : hexStr;\n\tconst padded = normalized.length % 2 === 0 ? normalized : `0${normalized}`;\n\tconst intArr = padded.match(/[0-9a-fA-F]{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];\n\n\tif (intArr.length !== padded.length / 2) {\n\t\tthrow new Error(`Invalid hex string ${hexStr}`);\n\t}\n\n\treturn Uint8Array.from(intArr);\n}\n\nexport function toHex(bytes: Uint8Array): string {\n\treturn bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n\n/** @deprecated use toHex instead */\nexport const toHEX = toHex;\n\n/** @deprecated use fromHex instead */\nexport const fromHEX = fromHex;\n"],"names":[],"mappings":";;;;;;AAGO,SAAS,QAAQ,MAAA,EAA4B;;IACnD,MAAM,aAAa,OAAO,UAAA,CAAW,IAAI,IAAI,OAAO,KAAA,CAAM,CAAC,IAAI;IAC/D,MAAM,SAAS,WAAW,MAAA,GAAS,MAAM,IAAI,aAAa,IAAc,OAAV,UAAU;QACzD;IAAf,MAAM,sDAAgB,KAAA,CAAM,iBAAiB,iEAAG,GAAA,CAAI,CAAC,OAAS,SAAS,MAAM,EAAE,CAAC,kEAAK,CAAC,CAAA;IAEtF,IAAI,OAAO,MAAA,KAAW,OAAO,MAAA,GAAS,GAAG;QACxC,MAAM,IAAI,MAAM,sBAA4B,CAAE,MAAR,MAAM;IAC7C;IAEA,OAAO,WAAW,IAAA,CAAK,MAAM;AAC9B;AAEO,SAAS,MAAM,KAAA,EAA2B;IAChD,OAAO,MAAM,MAAA,CAAO,CAAC,KAAK,OAAS,MAAM,KAAK,QAAA,CAAS,EAAE,EAAE,QAAA,CAAS,GAAG,GAAG,GAAG,EAAE;AAChF;AAGO,MAAM,QAAQ;AAGd,MAAM,UAAU","debugId":null}},
    {"offset": {"line": 80, "column": 0}, "map": {"version":3,"sources":["file:///D:/printx/redmoo/node_modules/%40mysten/sui/node_modules/%40mysten/bcs/src/uleb.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// Helper utility: write number as an ULEB array.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebEncode(num: number): number[] {\n\tlet arr = [];\n\tlet len = 0;\n\n\tif (num === 0) {\n\t\treturn [0];\n\t}\n\n\twhile (num > 0) {\n\t\tarr[len] = num & 0x7f;\n\t\tif ((num >>= 7)) {\n\t\t\tarr[len] |= 0x80;\n\t\t}\n\t\tlen += 1;\n\t}\n\n\treturn arr;\n}\n\n// Helper utility: decode ULEB as an array of numbers.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebDecode(arr: number[] | Uint8Array): {\n\tvalue: number;\n\tlength: number;\n} {\n\tlet total = 0;\n\tlet shift = 0;\n\tlet len = 0;\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tlet byte = arr[len];\n\t\tlen += 1;\n\t\ttotal |= (byte & 0x7f) << shift;\n\t\tif ((byte & 0x80) === 0) {\n\t\t\tbreak;\n\t\t}\n\t\tshift += 7;\n\t}\n\n\treturn {\n\t\tvalue: total,\n\t\tlength: len,\n\t};\n}\n"],"names":[],"mappings":";;;;AAKO,SAAS,WAAW,GAAA,EAAuB;IACjD,IAAI,MAAM,CAAC,CAAA;IACX,IAAI,MAAM;IAEV,IAAI,QAAQ,GAAG;QACd,OAAO;YAAC,CAAC;SAAA;IACV;IAEA,MAAO,MAAM,EAAG;QACf,GAAA,CAAI,GAAG,CAAA,GAAI,MAAM;QACjB,IAAK,QAAQ,GAAI;YAChB,GAAA,CAAI,GAAG,CAAA,IAAK;QACb;QACA,OAAO;IACR;IAEA,OAAO;AACR;AAIO,SAAS,WAAW,GAAA,EAGzB;IACD,IAAI,QAAQ;IACZ,IAAI,QAAQ;IACZ,IAAI,MAAM;IAGV,MAAO,KAAM;QACZ,IAAI,OAAO,GAAA,CAAI,GAAG,CAAA;QAClB,OAAO;QACP,SAAA,CAAU,OAAO,GAAA,KAAS;QAC1B,IAAA,CAAK,OAAO,GAAA,MAAU,GAAG;YACxB;QACD;QACA,SAAS;IACV;IAEA,OAAO;QACN,OAAO;QACP,QAAQ;IACT;AACD","debugId":null}},
    {"offset": {"line": 125, "column": 0}, "map": {"version":3,"sources":["file:///D:/printx/redmoo/node_modules/%40mysten/sui/node_modules/%40mysten/bcs/src/reader.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb.js';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\n\t/**\n\t * @param {Uint8Array} data Data to use as a buffer.\n\t */\n\tconstructor(data: Uint8Array) {\n\t\tthis.dataView = new DataView(data.buffer);\n\t}\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number) {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Read U8 value from the buffer and shift cursor by 1.\n\t * @returns\n\t */\n\tread8(): number {\n\t\tlet value = this.dataView.getUint8(this.bytePosition);\n\t\tthis.shift(1);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U16 value from the buffer and shift cursor by 2.\n\t * @returns\n\t */\n\tread16(): number {\n\t\tlet value = this.dataView.getUint16(this.bytePosition, true);\n\t\tthis.shift(2);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U32 value from the buffer and shift cursor by 4.\n\t * @returns\n\t */\n\tread32(): number {\n\t\tlet value = this.dataView.getUint32(this.bytePosition, true);\n\t\tthis.shift(4);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U64 value from the buffer and shift cursor by 8.\n\t * @returns\n\t */\n\tread64(): string {\n\t\tlet value1 = this.read32();\n\t\tlet value2 = this.read32();\n\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 16.\n\t */\n\tread128(): string {\n\t\tlet value1 = BigInt(this.read64());\n\t\tlet value2 = BigInt(this.read64());\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 32.\n\t * @returns\n\t */\n\tread256(): string {\n\t\tlet value1 = BigInt(this.read128());\n\t\tlet value2 = BigInt(this.read128());\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read `num` number of bytes from the buffer and shift cursor by `num`.\n\t * @param num Number of bytes to read.\n\t */\n\treadBytes(num: number): Uint8Array {\n\t\tlet start = this.bytePosition + this.dataView.byteOffset;\n\t\tlet value = new Uint8Array(this.dataView.buffer, start, num);\n\n\t\tthis.shift(num);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read ULEB value - an integer of varying size. Used for enum indexes and\n\t * vector lengths.\n\t * @returns {Number} The ULEB value.\n\t */\n\treadULEB(): number {\n\t\tlet start = this.bytePosition + this.dataView.byteOffset;\n\t\tlet buffer = new Uint8Array(this.dataView.buffer, start);\n\t\tlet { value, length } = ulebDecode(buffer);\n\n\t\tthis.shift(length);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read a BCS vector: read a length and then apply function `cb` X times\n\t * where X is the length of the vector, defined as ULEB in BCS bytes.\n\t * @param cb Callback to process elements of vector.\n\t * @returns {Array<Any>} Array of the resulting values, returned by callback.\n\t */\n\treadVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n\t\tlet length = this.readULEB();\n\t\tlet result = [];\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult.push(cb(this, i, length));\n\t\t}\n\t\treturn result;\n\t}\n}\n"],"names":[],"mappings":";;;AAGA,SAAS,kBAAkB;;AAgCpB,MAAM,UAAU;IAStB;;;;;GAAA,GAOA,MAAM,KAAA,EAAe;QACpB,IAAA,CAAK,YAAA,IAAgB;QACrB,OAAO,IAAA;IACR;IAAA;;;GAAA,GAKA,QAAgB;QACf,IAAI,QAAQ,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,IAAA,CAAK,YAAY;QACpD,IAAA,CAAK,KAAA,CAAM,CAAC;QACZ,OAAO;IACR;IAAA;;;GAAA,GAKA,SAAiB;QAChB,IAAI,QAAQ,IAAA,CAAK,QAAA,CAAS,SAAA,CAAU,IAAA,CAAK,YAAA,EAAc,IAAI;QAC3D,IAAA,CAAK,KAAA,CAAM,CAAC;QACZ,OAAO;IACR;IAAA;;;GAAA,GAKA,SAAiB;QAChB,IAAI,QAAQ,IAAA,CAAK,QAAA,CAAS,SAAA,CAAU,IAAA,CAAK,YAAA,EAAc,IAAI;QAC3D,IAAA,CAAK,KAAA,CAAM,CAAC;QACZ,OAAO;IACR;IAAA;;;GAAA,GAKA,SAAiB;QAChB,IAAI,SAAS,IAAA,CAAK,MAAA,CAAO;QACzB,IAAI,SAAS,IAAA,CAAK,MAAA,CAAO;QAEzB,IAAI,SAAS,OAAO,QAAA,CAAS,EAAE,IAAI,OAAO,QAAA,CAAS,EAAE,EAAE,QAAA,CAAS,GAAG,GAAG;QAEtE,OAAO,OAAO,OAAO,MAAM,EAAE,QAAA,CAAS,EAAE;IACzC;IAAA;;GAAA,GAIA,UAAkB;QACjB,IAAI,SAAS,OAAO,IAAA,CAAK,MAAA,CAAO,CAAC;QACjC,IAAI,SAAS,OAAO,IAAA,CAAK,MAAA,CAAO,CAAC;QACjC,IAAI,SAAS,OAAO,QAAA,CAAS,EAAE,IAAI,OAAO,QAAA,CAAS,EAAE,EAAE,QAAA,CAAS,IAAI,GAAG;QAEvE,OAAO,OAAO,OAAO,MAAM,EAAE,QAAA,CAAS,EAAE;IACzC;IAAA;;;GAAA,GAKA,UAAkB;QACjB,IAAI,SAAS,OAAO,IAAA,CAAK,OAAA,CAAQ,CAAC;QAClC,IAAI,SAAS,OAAO,IAAA,CAAK,OAAA,CAAQ,CAAC;QAClC,IAAI,SAAS,OAAO,QAAA,CAAS,EAAE,IAAI,OAAO,QAAA,CAAS,EAAE,EAAE,QAAA,CAAS,IAAI,GAAG;QAEvE,OAAO,OAAO,OAAO,MAAM,EAAE,QAAA,CAAS,EAAE;IACzC;IAAA;;;GAAA,GAKA,UAAU,GAAA,EAAyB;QAClC,IAAI,QAAQ,IAAA,CAAK,YAAA,GAAe,IAAA,CAAK,QAAA,CAAS,UAAA;QAC9C,IAAI,QAAQ,IAAI,WAAW,IAAA,CAAK,QAAA,CAAS,MAAA,EAAQ,OAAO,GAAG;QAE3D,IAAA,CAAK,KAAA,CAAM,GAAG;QAEd,OAAO;IACR;IAAA;;;;GAAA,GAMA,WAAmB;QAClB,IAAI,QAAQ,IAAA,CAAK,YAAA,GAAe,IAAA,CAAK,QAAA,CAAS,UAAA;QAC9C,IAAI,SAAS,IAAI,WAAW,IAAA,CAAK,QAAA,CAAS,MAAA,EAAQ,KAAK;QACvD,IAAI,EAAE,KAAA,EAAO,MAAA,CAAO,CAAA,6LAAI,aAAA,EAAW,MAAM;QAEzC,IAAA,CAAK,KAAA,CAAM,MAAM;QAEjB,OAAO;IACR;IAAA;;;;;GAAA,GAOA,QAAQ,EAAA,EAAkE;QACzE,IAAI,SAAS,IAAA,CAAK,QAAA,CAAS;QAC3B,IAAI,SAAS,CAAC,CAAA;QACd,IAAA,IAAS,IAAI,GAAG,IAAI,QAAQ,IAAK;YAChC,OAAO,IAAA,CAAK,GAAG,IAAA,EAAM,GAAG,MAAM,CAAC;QAChC;QACA,OAAO;IACR;IAvHsB;;GAAA,GAOtB,YAAY,IAAA,CAAkB;QAL9B,IAAA,CAAQ,YAAA,GAAuB;QAM9B,IAAA,CAAK,QAAA,GAAW,IAAI,SAAS,KAAK,MAAM;IACzC;AA+GD","debugId":null}},
    {"offset": {"line": 236, "column": 0}, "map": {"version":3,"sources":["file:///D:/printx/redmoo/node_modules/%40mysten/sui/node_modules/%40mysten/bcs/src/utils.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, toBase58 } from './b58.js';\nimport { fromBase64, toBase64 } from './b64.js';\nimport { fromHex, toHex } from './hex.js';\nimport type { Encoding } from './types.js';\n\n/**\n * Encode data with either `hex` or `base64`.\n *\n * @param {Uint8Array} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {String} Encoded value.\n */\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn toBase58(data);\n\t\tcase 'base64':\n\t\t\treturn toBase64(data);\n\t\tcase 'hex':\n\t\t\treturn toHex(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\n/**\n * Decode either `base64` or `hex` data.\n *\n * @param {String} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {Uint8Array} Encoded value.\n */\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn fromBase58(data);\n\t\tcase 'base64':\n\t\t\treturn fromBase64(data);\n\t\tcase 'hex':\n\t\t\treturn fromHex(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\nexport function splitGenericParameters(\n\tstr: string,\n\tgenericSeparators: [string, string] = ['<', '>'],\n) {\n\tconst [left, right] = genericSeparators;\n\tconst tok = [];\n\tlet word = '';\n\tlet nestedAngleBrackets = 0;\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst char = str[i];\n\t\tif (char === left) {\n\t\t\tnestedAngleBrackets++;\n\t\t}\n\t\tif (char === right) {\n\t\t\tnestedAngleBrackets--;\n\t\t}\n\t\tif (nestedAngleBrackets === 0 && char === ',') {\n\t\t\ttok.push(word.trim());\n\t\t\tword = '';\n\t\t\tcontinue;\n\t\t}\n\t\tword += char;\n\t}\n\n\ttok.push(word.trim());\n\n\treturn tok;\n}\n"],"names":[],"mappings":";;;;;AAGA,SAAS,YAAY,gBAAgB;AACrC,SAAS,YAAY,gBAAgB;AACrC,SAAS,SAAS,aAAa;;;;AAUxB,SAAS,UAAU,IAAA,EAAkB,QAAA,EAA4B;IACvE,OAAQ,UAAU;QACjB,KAAK;YACJ,gMAAO,WAAA,EAAS,IAAI;QACrB,KAAK;YACJ,WAAO,gMAAA,EAAS,IAAI;QACrB,KAAK;YACJ,gMAAO,QAAA,EAAM,IAAI;QAClB;YACC,MAAM,IAAI,MAAM,yDAAyD;IAC3E;AACD;AASO,SAAS,UAAU,IAAA,EAAc,QAAA,EAAgC;IACvE,OAAQ,UAAU;QACjB,KAAK;YACJ,gMAAO,aAAA,EAAW,IAAI;QACvB,KAAK;YACJ,QAAO,qMAAA,EAAW,IAAI;QACvB,KAAK;YACJ,gMAAO,UAAA,EAAQ,IAAI;QACpB;YACC,MAAM,IAAI,MAAM,yDAAyD;IAC3E;AACD;AAEO,SAAS,uBACf,GAAA;4BACA,iEAAsC;QAAC;QAAK,GAAG;KAAA,EAC9C;IACD,MAAM,CAAC,MAAM,KAAK,CAAA,GAAI;IACtB,MAAM,MAAM,CAAC,CAAA;IACb,IAAI,OAAO;IACX,IAAI,sBAAsB;IAE1B,IAAA,IAAS,IAAI,GAAG,IAAI,IAAI,MAAA,EAAQ,IAAK;QACpC,MAAM,OAAO,GAAA,CAAI,CAAC,CAAA;QAClB,IAAI,SAAS,MAAM;YAClB;QACD;QACA,IAAI,SAAS,OAAO;YACnB;QACD;QACA,IAAI,wBAAwB,KAAK,SAAS,KAAK;YAC9C,IAAI,IAAA,CAAK,KAAK,IAAA,CAAK,CAAC;YACpB,OAAO;YACP;QACD;QACA,QAAQ;IACT;IAEA,IAAI,IAAA,CAAK,KAAK,IAAA,CAAK,CAAC;IAEpB,OAAO;AACR","debugId":null}},
    {"offset": {"line": 304, "column": 0}, "map": {"version":3,"sources":["file:///D:/printx/redmoo/node_modules/%40mysten/sui/node_modules/%40mysten/bcs/src/writer.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Encoding } from './types.js';\nimport { ulebEncode } from './uleb.js';\nimport { encodeStr } from './utils.js';\n\nexport interface BcsWriterOptions {\n\t/** The initial size (in bytes) of the buffer tht will be allocated */\n\tinitialSize?: number;\n\t/** The maximum size (in bytes) that the buffer is allowed to grow to */\n\tmaxSize?: number;\n\t/** The amount of bytes that will be allocated whenever additional memory is required */\n\tallocateSize?: number;\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport class BcsWriter {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\tprivate size: number;\n\tprivate maxSize: number;\n\tprivate allocateSize: number;\n\n\tconstructor({\n\t\tinitialSize = 1024,\n\t\tmaxSize = Infinity,\n\t\tallocateSize = 1024,\n\t}: BcsWriterOptions = {}) {\n\t\tthis.size = initialSize;\n\t\tthis.maxSize = maxSize;\n\t\tthis.allocateSize = allocateSize;\n\t\tthis.dataView = new DataView(new ArrayBuffer(initialSize));\n\t}\n\n\tprivate ensureSizeOrGrow(bytes: number) {\n\t\tconst requiredSize = this.bytePosition + bytes;\n\t\tif (requiredSize > this.size) {\n\t\t\tconst nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n\t\t\tif (requiredSize > nextSize) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.size = nextSize;\n\t\t\tconst nextBuffer = new ArrayBuffer(this.size);\n\t\t\tnew Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n\t\t\tthis.dataView = new DataView(nextBuffer);\n\t\t}\n\t}\n\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number): this {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U8 value into a buffer and shift cursor position by 1.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite8(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(1);\n\t\tthis.dataView.setUint8(this.bytePosition, Number(value));\n\t\treturn this.shift(1);\n\t}\n\t/**\n\t * Write a U16 value into a buffer and shift cursor position by 2.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite16(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(2);\n\t\tthis.dataView.setUint16(this.bytePosition, Number(value), true);\n\t\treturn this.shift(2);\n\t}\n\t/**\n\t * Write a U32 value into a buffer and shift cursor position by 4.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite32(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(4);\n\t\tthis.dataView.setUint32(this.bytePosition, Number(value), true);\n\t\treturn this.shift(4);\n\t}\n\t/**\n\t * Write a U64 value into a buffer and shift cursor position by 8.\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite64(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U128 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite128(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U256 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite256(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a ULEB value into a buffer and shift cursor position by number of bytes\n\t * written.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twriteULEB(value: number): this {\n\t\tulebEncode(value).forEach((el) => this.write8(el));\n\t\treturn this;\n\t}\n\t/**\n\t * Write a vector into a buffer by first writing the vector length and then calling\n\t * a callback on each passed value.\n\t *\n\t * @param {Array<Any>} vector Array of elements to write.\n\t * @param {WriteVecCb} cb Callback to call on each element of the vector.\n\t * @returns {this}\n\t */\n\twriteVec(vector: any[], cb: (writer: BcsWriter, el: any, i: number, len: number) => void): this {\n\t\tthis.writeULEB(vector.length);\n\t\tArray.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds support for iterations over the object.\n\t * @returns {Uint8Array}\n\t */\n\t*[Symbol.iterator](): Iterator<number, Iterable<number>> {\n\t\tfor (let i = 0; i < this.bytePosition; i++) {\n\t\t\tyield this.dataView.getUint8(i);\n\t\t}\n\t\treturn this.toBytes();\n\t}\n\n\t/**\n\t * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n\t * @returns {Uint8Array} Resulting bcs.\n\t */\n\ttoBytes(): Uint8Array {\n\t\treturn new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n\t}\n\n\t/**\n\t * Represent data as 'hex' or 'base64'\n\t * @param encoding Encoding to use: 'base64' or 'hex'\n\t */\n\ttoString(encoding: Encoding): string {\n\t\treturn encodeStr(this.toBytes(), encoding);\n\t}\n}\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n\tlet result = new Uint8Array(size);\n\tlet i = 0;\n\twhile (bigint > 0) {\n\t\tresult[i] = Number(bigint % BigInt(256));\n\t\tbigint = bigint / BigInt(256);\n\t\ti += 1;\n\t}\n\treturn result;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 453, "column": 0}, "map": {"version":3,"sources":["file:///D:/printx/redmoo/node_modules/%40mysten/sui/node_modules/%40mysten/bcs/src/bcs-type.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase58, toBase58 } from './b58.js';\nimport { fromBase64, toBase64 } from './b64.js';\nimport { fromHex, toHex } from './hex.js';\nimport { BcsReader } from './reader.js';\nimport { ulebEncode } from './uleb.js';\nimport type { BcsWriterOptions } from './writer.js';\nimport { BcsWriter } from './writer.js';\n\nexport interface BcsTypeOptions<T, Input = T> {\n\tname?: string;\n\tvalidate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T> {\n\t$inferType!: T;\n\t$inferInput!: Input;\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n\tvalidate: (value: Input) => void;\n\t#write: (value: Input, writer: BcsWriter) => void;\n\t#serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\n\tconstructor(\n\t\toptions: {\n\t\t\tname: string;\n\t\t\tread: (reader: BcsReader) => T;\n\t\t\twrite: (value: Input, writer: BcsWriter) => void;\n\t\t\tserialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\t\t\tserializedSize?: (value: Input) => number | null;\n\t\t\tvalidate?: (value: Input) => void;\n\t\t} & BcsTypeOptions<T, Input>,\n\t) {\n\t\tthis.name = options.name;\n\t\tthis.read = options.read;\n\t\tthis.serializedSize = options.serializedSize ?? (() => null);\n\t\tthis.#write = options.write;\n\t\tthis.#serialize =\n\t\t\toptions.serialize ??\n\t\t\t((value, options) => {\n\t\t\t\tconst writer = new BcsWriter({\n\t\t\t\t\tinitialSize: this.serializedSize(value) ?? undefined,\n\t\t\t\t\t...options,\n\t\t\t\t});\n\t\t\t\tthis.#write(value, writer);\n\t\t\t\treturn writer.toBytes();\n\t\t\t});\n\n\t\tthis.validate = options.validate ?? (() => {});\n\t}\n\n\twrite(value: Input, writer: BcsWriter) {\n\t\tthis.validate(value);\n\t\tthis.#write(value, writer);\n\t}\n\n\tserialize(value: Input, options?: BcsWriterOptions) {\n\t\tthis.validate(value);\n\t\treturn new SerializedBcs(this, this.#serialize(value, options));\n\t}\n\n\tparse(bytes: Uint8Array): T {\n\t\tconst reader = new BcsReader(bytes);\n\t\treturn this.read(reader);\n\t}\n\n\tfromHex(hex: string) {\n\t\treturn this.parse(fromHex(hex));\n\t}\n\n\tfromBase58(b64: string) {\n\t\treturn this.parse(fromBase58(b64));\n\t}\n\n\tfromBase64(b64: string) {\n\t\treturn this.parse(fromBase64(b64));\n\t}\n\n\ttransform<T2 = T, Input2 = Input>({\n\t\tname,\n\t\tinput,\n\t\toutput,\n\t\tvalidate,\n\t}: {\n\t\tinput?: (val: Input2) => Input;\n\t\toutput?: (value: T) => T2;\n\t} & BcsTypeOptions<T2, Input2>) {\n\t\treturn new BcsType<T2, Input2>({\n\t\t\tname: name ?? this.name,\n\t\t\tread: (reader) => (output ? output(this.read(reader)) : (this.read(reader) as never)),\n\t\t\twrite: (value, writer) => this.#write(input ? input(value) : (value as never), writer),\n\t\t\tserializedSize: (value) => this.serializedSize(input ? input(value) : (value as never)),\n\t\t\tserialize: (value, options) =>\n\t\t\t\tthis.#serialize(input ? input(value) : (value as never), options),\n\t\t\tvalidate: (value) => {\n\t\t\t\tvalidate?.(value);\n\t\t\t\tthis.validate(input ? input(value) : (value as never));\n\t\t\t},\n\t\t});\n\t}\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@mysten/serialized-bcs') as never;\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n\t#schema: BcsType<T, Input>;\n\t#bytes: Uint8Array;\n\n\t// Used to brand SerializedBcs so that they can be identified, even between multiple copies\n\t// of the @mysten/bcs package are installed\n\tget [SERIALIZED_BCS_BRAND]() {\n\t\treturn true;\n\t}\n\n\tconstructor(type: BcsType<T, Input>, schema: Uint8Array) {\n\t\tthis.#schema = type;\n\t\tthis.#bytes = schema;\n\t}\n\n\ttoBytes() {\n\t\treturn this.#bytes;\n\t}\n\n\ttoHex() {\n\t\treturn toHex(this.#bytes);\n\t}\n\n\ttoBase64() {\n\t\treturn toBase64(this.#bytes);\n\t}\n\n\ttoBase58() {\n\t\treturn toBase58(this.#bytes);\n\t}\n\n\tparse() {\n\t\treturn this.#schema.parse(this.#bytes);\n\t}\n}\n\nexport function fixedSizeBcsType<T, Input = T>({\n\tsize,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\tread: (reader: BcsReader) => T;\n\twrite: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input>) {\n\treturn new BcsType<T, Input>({\n\t\t...options,\n\t\tserializedSize: () => size,\n\t});\n}\n\nexport function uIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${8 | 16 | 32}`;\n\twriteMethod: `write${8 | 16 | 32}`;\n\tmaxValue: number;\n} & BcsTypeOptions<number, number>) {\n\treturn fixedSizeBcsType<number>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](value),\n\t\tvalidate: (value) => {\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function bigUIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${64 | 128 | 256}`;\n\twriteMethod: `write${64 | 128 | 256}`;\n\tmaxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n\treturn fixedSizeBcsType<string, string | number | bigint>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](BigInt(value)),\n\t\tvalidate: (val) => {\n\t\t\tconst value = BigInt(val);\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function dynamicSizeBcsType<T, Input = T>({\n\tserialize,\n\t...options\n}: {\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n} & BcsTypeOptions<T, Input>) {\n\tconst type = new BcsType<T, Input>({\n\t\t...options,\n\t\tserialize,\n\t\twrite: (value, writer) => {\n\t\t\tfor (const byte of type.serialize(value).toBytes()) {\n\t\t\t\twriter.write8(byte);\n\t\t\t}\n\t\t},\n\t});\n\n\treturn type;\n}\n\nexport function stringLikeBcsType({\n\ttoBytes,\n\tfromBytes,\n\t...options\n}: {\n\tname: string;\n\ttoBytes: (value: string) => Uint8Array;\n\tfromBytes: (bytes: Uint8Array) => string;\n\tserializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string>) {\n\treturn new BcsType<string>({\n\t\t...options,\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst bytes = reader.readBytes(length);\n\n\t\t\treturn fromBytes(bytes);\n\t\t},\n\t\twrite: (hex, writer) => {\n\t\t\tconst bytes = toBytes(hex);\n\t\t\twriter.writeULEB(bytes.length);\n\t\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\t\twriter.write8(bytes[i]);\n\t\t\t}\n\t\t},\n\t\tserialize: (value) => {\n\t\t\tconst bytes = toBytes(value);\n\t\t\tconst size = ulebEncode(bytes.length);\n\t\t\tconst result = new Uint8Array(size.length + bytes.length);\n\t\t\tresult.set(size, 0);\n\t\t\tresult.set(bytes, size.length);\n\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: (value) => {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n\tlet lazyType: BcsType<T, Input> | null = null;\n\tfunction getType() {\n\t\tif (!lazyType) {\n\t\t\tlazyType = cb();\n\t\t}\n\t\treturn lazyType;\n\t}\n\n\treturn new BcsType<T, Input>({\n\t\tname: 'lazy' as never,\n\t\tread: (data) => getType().read(data),\n\t\tserializedSize: (value) => getType().serializedSize(value),\n\t\twrite: (value, writer) => getType().write(value, writer),\n\t\tserialize: (value, options) => getType().serialize(value, options).toBytes(),\n\t});\n}\n"],"names":["options"],"mappings":"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","debugId":null}},
    {"offset": {"line": 685, "column": 0}, "map": {"version":3,"sources":["file:///D:/printx/redmoo/node_modules/%40mysten/sui/node_modules/%40mysten/bcs/src/bcs.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsTypeOptions } from './bcs-type.js';\nimport {\n\tBcsType,\n\tbigUIntBcsType,\n\tdynamicSizeBcsType,\n\tfixedSizeBcsType,\n\tlazyBcsType,\n\tstringLikeBcsType,\n\tuIntBcsType,\n} from './bcs-type.js';\nimport type { EnumInputShape, EnumOutputShape } from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nexport const bcs = {\n\t/**\n\t * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n\t * @example\n\t * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n\t */\n\tu8(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u8',\n\t\t\treadMethod: 'read8',\n\t\t\twriteMethod: 'write8',\n\t\t\tsize: 1,\n\t\t\tmaxValue: 2 ** 8 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n\t * @example\n\t * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n\t */\n\tu16(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u16',\n\t\t\treadMethod: 'read16',\n\t\t\twriteMethod: 'write16',\n\t\t\tsize: 2,\n\t\t\tmaxValue: 2 ** 16 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n\t * @example\n\t * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n\t */\n\tu32(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u32',\n\t\t\treadMethod: 'read32',\n\t\t\twriteMethod: 'write32',\n\t\t\tsize: 4,\n\t\t\tmaxValue: 2 ** 32 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n\t * @example\n\t * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n\t */\n\tu64(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u64',\n\t\t\treadMethod: 'read64',\n\t\t\twriteMethod: 'write64',\n\t\t\tsize: 8,\n\t\t\tmaxValue: 2n ** 64n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n\t * @example\n\t * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu128(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u128',\n\t\t\treadMethod: 'read128',\n\t\t\twriteMethod: 'write128',\n\t\t\tsize: 16,\n\t\t\tmaxValue: 2n ** 128n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n\t * @example\n\t * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu256(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u256',\n\t\t\treadMethod: 'read256',\n\t\t\twriteMethod: 'write256',\n\t\t\tsize: 32,\n\t\t\tmaxValue: 2n ** 256n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write boolean values.\n\t * @example\n\t * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n\t */\n\tbool(options?: BcsTypeOptions<boolean>) {\n\t\treturn fixedSizeBcsType<boolean>({\n\t\t\tname: 'bool',\n\t\t\tsize: 1,\n\t\t\tread: (reader) => reader.read8() === 1,\n\t\t\twrite: (value, writer) => writer.write8(value ? 1 : 0),\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'boolean') {\n\t\t\t\t\tthrow new TypeError(`Expected boolean, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n\t * @example\n\t *\n\t */\n\tuleb128(options?: BcsTypeOptions<number>) {\n\t\treturn dynamicSizeBcsType<number>({\n\t\t\tname: 'uleb128',\n\t\t\tread: (reader) => reader.readULEB(),\n\t\t\tserialize: (value) => {\n\t\t\t\treturn Uint8Array.from(ulebEncode(value));\n\t\t\t},\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a fixed length byte array\n\t * @param size The number of bytes this types represents\n\t * @example\n\t * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n\t */\n\tbytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn fixedSizeBcsType<Uint8Array, Iterable<number>>({\n\t\t\tname: `bytes[${size}]`,\n\t\t\tsize,\n\t\t\tread: (reader) => reader.readBytes(size),\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst array = new Uint8Array(value);\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\twriter.write8(array[i] ?? 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length byte array\n\t *\n\t * @example\n\t * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]\n\t */\n\tbyteVector(options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn new BcsType<Uint8Array, Iterable<number>>({\n\t\t\tname: `bytesVector`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\n\t\t\t\treturn reader.readBytes(length);\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst array = new Uint8Array(value);\n\t\t\t\twriter.writeULEB(array.length);\n\t\t\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\t\t\twriter.write8(array[i] ?? 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tserializedSize: (value) => {\n\t\t\t\tconst length = 'length' in value ? (value.length as number) : null;\n\t\t\t\treturn length == null ? null : ulebEncode(length).length + length;\n\t\t\t},\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n\t * @example\n\t * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n\t */\n\tstring(options?: BcsTypeOptions<string>) {\n\t\treturn stringLikeBcsType({\n\t\t\tname: 'string',\n\t\t\ttoBytes: (value) => new TextEncoder().encode(value),\n\t\t\tfromBytes: (bytes) => new TextDecoder().decode(bytes),\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that represents a fixed length array of a given type\n\t * @param size The number of elements in the array\n\t * @param type The BcsType of each element in the array\n\t * @example\n\t * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n\t */\n\tfixedArray<T, Input>(\n\t\tsize: number,\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `${type.name}[${size}]`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: T[] = new Array(size);\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an optional value\n\t * @param type The BcsType of the optional value\n\t * @example\n\t * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n\t * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n\t */\n\toption<T, Input>(type: BcsType<T, Input>) {\n\t\treturn bcs\n\t\t\t.enum(`Option<${type.name}>`, {\n\t\t\t\tNone: null,\n\t\t\t\tSome: type,\n\t\t\t})\n\t\t\t.transform({\n\t\t\t\tinput: (value: Input | null | undefined) => {\n\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\treturn { None: true };\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { Some: value };\n\t\t\t\t},\n\t\t\t\toutput: (value) => {\n\t\t\t\t\tif (value.$kind === 'Some') {\n\t\t\t\t\t\treturn value.Some;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length vector of a given type\n\t * @param type The BcsType of each element in the vector\n\t *\n\t * @example\n\t * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n\t */\n\tvector<T, Input>(\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `vector<${type.name}>`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\t\t\t\tconst result: T[] = new Array(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\twriter.writeULEB(value.length);\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!value || typeof value !== 'object' || !('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a tuple of a given set of types\n\t * @param types The BcsTypes for each element in the tuple\n\t *\n\t * @example\n\t * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n\t * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n\t */\n\ttuple<const Types extends readonly BcsType<any>[]>(\n\t\ttypes: Types,\n\t\toptions?: BcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>,\n\t) {\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>({\n\t\t\tname: `(${types.map((t) => t.name).join(', ')})`,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\tconst size = types[i].serializedSize(values[i]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: unknown[] = [];\n\t\t\t\tfor (const type of types) {\n\t\t\t\t\tresult.push(type.read(reader));\n\t\t\t\t}\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\ttypes[i].write(value[i], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== types.length) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${types.length}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a struct of a given set of fields\n\t * @param name The name of the struct\n\t * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n\t *\n\t * @example\n\t * const struct = bcs.struct('MyStruct', {\n\t *  a: bcs.u8(),\n\t *  b: bcs.string(),\n\t * })\n\t * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t */\n\tstruct<T extends Record<string, BcsType<any>>>(\n\t\tname: string,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t\t}\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(fields);\n\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t}\n\t\t>({\n\t\t\tname,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tconst size = type.serializedSize(values[field]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: Record<string, unknown> = {};\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tresult[field] = type.read(reader);\n\t\t\t\t}\n\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\ttype.write(value[field], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an enum of a given set of options\n\t * @param name The name of the enum\n\t * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n\t * null can be used to represent a variant with no data.\n\t *\n\t * @example\n\t * const enum = bcs.enum('MyEnum', {\n\t *   A: bcs.u8(),\n\t *   B: bcs.string(),\n\t *   C: null,\n\t * })\n\t * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n\t * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n\t */\n\tenum<T extends Record<string, BcsType<any> | null>>(\n\t\tname: string,\n\t\tvalues: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\tEnumOutputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t\t\t\t}>,\n\t\t\t\tEnumInputShape<{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n\t\t\t\t}>\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(values as object);\n\t\treturn new BcsType<\n\t\t\tEnumOutputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : true;\n\t\t\t}>,\n\t\t\tEnumInputShape<{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : boolean | object | null;\n\t\t\t}>\n\t\t>({\n\t\t\tname,\n\t\t\tread: (reader) => {\n\t\t\t\tconst index = reader.readULEB();\n\n\t\t\t\tconst enumEntry = canonicalOrder[index];\n\t\t\t\tif (!enumEntry) {\n\t\t\t\t\tthrow new TypeError(`Unknown value ${index} for enum ${name}`);\n\t\t\t\t}\n\n\t\t\t\tconst [kind, type] = enumEntry;\n\n\t\t\t\treturn {\n\t\t\t\t\t[kind]: type?.read(reader) ?? true,\n\t\t\t\t\t$kind: kind,\n\t\t\t\t} as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst [name, val] = Object.entries(value).filter(([name]) =>\n\t\t\t\t\tObject.hasOwn(values, name),\n\t\t\t\t)[0];\n\n\t\t\t\tfor (let i = 0; i < canonicalOrder.length; i++) {\n\t\t\t\t\tconst [optionName, optionType] = canonicalOrder[i];\n\t\t\t\t\tif (optionName === name) {\n\t\t\t\t\t\twriter.writeULEB(i);\n\t\t\t\t\t\toptionType?.write(val, writer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\n\t\t\t\tconst keys = Object.keys(value).filter(\n\t\t\t\t\t(k) => value[k] !== undefined && Object.hasOwn(values, k),\n\t\t\t\t);\n\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t`Expected object with one key, but found ${keys.length} for type ${name}}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst [variant] = keys;\n\n\t\t\t\tif (!Object.hasOwn(values, variant)) {\n\t\t\t\t\tthrow new TypeError(`Invalid enum variant ${variant}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a map of a given key and value type\n\t * @param keyType The BcsType of the key\n\t * @param valueType The BcsType of the value\n\t * @example\n\t * const map = bcs.map(bcs.u8(), bcs.string())\n\t * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n\t */\n\tmap<K, V, InputK = K, InputV = V>(keyType: BcsType<K, InputK>, valueType: BcsType<V, InputV>) {\n\t\treturn bcs.vector(bcs.tuple([keyType, valueType])).transform({\n\t\t\tname: `Map<${keyType.name}, ${valueType.name}>`,\n\t\t\tinput: (value: Map<InputK, InputV>) => {\n\t\t\t\treturn [...value.entries()];\n\t\t\t},\n\t\t\toutput: (value) => {\n\t\t\t\tconst result = new Map<K, V>();\n\t\t\t\tfor (const [key, val] of value) {\n\t\t\t\t\tresult.set(key, val);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n\t * @param cb A callback that returns the BcsType\n\t */\n\tlazy<T extends BcsType<any>>(cb: () => T): T {\n\t\treturn lazyBcsType(cb) as T;\n\t},\n};\n"],"names":["name"],"mappings":"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","debugId":null}},
    {"offset": {"line": 1181, "column": 0}, "map": {"version":3,"sources":["file:///D:/printx/redmoo/node_modules/%40mysten/wallet-kit/node_modules/%40mysten/bcs/src/b58.ts","file:///D:/printx/redmoo/node_modules/%40mysten/wallet-kit/node_modules/%40mysten/bcs/src/b64.ts","file:///D:/printx/redmoo/node_modules/%40mysten/wallet-kit/node_modules/%40mysten/bcs/src/hex.ts","file:///D:/printx/redmoo/node_modules/%40mysten/wallet-kit/node_modules/%40mysten/bcs/src/uleb.ts","file:///D:/printx/redmoo/node_modules/%40mysten/wallet-kit/node_modules/%40mysten/bcs/src/reader.ts","file:///D:/printx/redmoo/node_modules/%40mysten/wallet-kit/node_modules/%40mysten/bcs/src/utils.ts","file:///D:/printx/redmoo/node_modules/%40mysten/wallet-kit/node_modules/%40mysten/bcs/src/writer.ts","file:///D:/printx/redmoo/node_modules/%40mysten/wallet-kit/node_modules/%40mysten/bcs/src/bcs-type.ts","file:///D:/printx/redmoo/node_modules/%40mysten/wallet-kit/node_modules/%40mysten/bcs/src/bcs.ts","file:///D:/printx/redmoo/node_modules/%40mysten/wallet-kit/node_modules/%40mysten/bcs/src/legacy-registry.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport bs58 from 'bs58';\n\nexport const toB58 = (buffer: Uint8Array) => bs58.encode(buffer);\nexport const fromB58 = (str: string) => bs58.decode(str);\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/*\\\n|*|  Base64 / binary data / UTF-8 strings utilities\n|*|  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding\n\\*/\n\n/* Array of bytes to Base64 string decoding */\n\nfunction b64ToUint6(nChr: number) {\n\treturn nChr > 64 && nChr < 91\n\t\t? nChr - 65\n\t\t: nChr > 96 && nChr < 123\n\t\t? nChr - 71\n\t\t: nChr > 47 && nChr < 58\n\t\t? nChr + 4\n\t\t: nChr === 43\n\t\t? 62\n\t\t: nChr === 47\n\t\t? 63\n\t\t: 0;\n}\n\nexport function fromB64(sBase64: string, nBlocksSize?: number): Uint8Array {\n\tvar sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, ''),\n\t\tnInLen = sB64Enc.length,\n\t\tnOutLen = nBlocksSize\n\t\t\t? Math.ceil(((nInLen * 3 + 1) >> 2) / nBlocksSize) * nBlocksSize\n\t\t\t: (nInLen * 3 + 1) >> 2,\n\t\ttaBytes = new Uint8Array(nOutLen);\n\n\tfor (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {\n\t\tnMod4 = nInIdx & 3;\n\t\tnUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << (6 * (3 - nMod4));\n\t\tif (nMod4 === 3 || nInLen - nInIdx === 1) {\n\t\t\tfor (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\n\t\t\t\ttaBytes[nOutIdx] = (nUint24 >>> ((16 >>> nMod3) & 24)) & 255;\n\t\t\t}\n\t\t\tnUint24 = 0;\n\t\t}\n\t}\n\n\treturn taBytes;\n}\n\n/* Base64 string to array encoding */\n\nfunction uint6ToB64(nUint6: number) {\n\treturn nUint6 < 26\n\t\t? nUint6 + 65\n\t\t: nUint6 < 52\n\t\t? nUint6 + 71\n\t\t: nUint6 < 62\n\t\t? nUint6 - 4\n\t\t: nUint6 === 62\n\t\t? 43\n\t\t: nUint6 === 63\n\t\t? 47\n\t\t: 65;\n}\n\nexport function toB64(aBytes: Uint8Array): string {\n\tvar nMod3 = 2,\n\t\tsB64Enc = '';\n\n\tfor (var nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {\n\t\tnMod3 = nIdx % 3;\n\t\tnUint24 |= aBytes[nIdx] << ((16 >>> nMod3) & 24);\n\t\tif (nMod3 === 2 || aBytes.length - nIdx === 1) {\n\t\t\tsB64Enc += String.fromCodePoint(\n\t\t\t\tuint6ToB64((nUint24 >>> 18) & 63),\n\t\t\t\tuint6ToB64((nUint24 >>> 12) & 63),\n\t\t\t\tuint6ToB64((nUint24 >>> 6) & 63),\n\t\t\t\tuint6ToB64(nUint24 & 63),\n\t\t\t);\n\t\t\tnUint24 = 0;\n\t\t}\n\t}\n\n\treturn (\n\t\tsB64Enc.slice(0, sB64Enc.length - 2 + nMod3) + (nMod3 === 2 ? '' : nMod3 === 1 ? '=' : '==')\n\t);\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromHEX(hexStr: string): Uint8Array {\n\tconst normalized = hexStr.startsWith('0x') ? hexStr.slice(2) : hexStr;\n\tconst padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;\n\tconst intArr = padded.match(/.{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];\n\n\treturn Uint8Array.from(intArr);\n}\n\nexport function toHEX(bytes: Uint8Array): string {\n\treturn bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// Helper utility: write number as an ULEB array.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebEncode(num: number): number[] {\n\tlet arr = [];\n\tlet len = 0;\n\n\tif (num === 0) {\n\t\treturn [0];\n\t}\n\n\twhile (num > 0) {\n\t\tarr[len] = num & 0x7f;\n\t\tif ((num >>= 7)) {\n\t\t\tarr[len] |= 0x80;\n\t\t}\n\t\tlen += 1;\n\t}\n\n\treturn arr;\n}\n\n// Helper utility: decode ULEB as an array of numbers.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nexport function ulebDecode(arr: number[] | Uint8Array): {\n\tvalue: number;\n\tlength: number;\n} {\n\tlet total = 0;\n\tlet shift = 0;\n\tlet len = 0;\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tlet byte = arr[len];\n\t\tlen += 1;\n\t\ttotal |= (byte & 0x7f) << shift;\n\t\tif ((byte & 0x80) === 0) {\n\t\t\tbreak;\n\t\t}\n\t\tshift += 7;\n\t}\n\n\treturn {\n\t\tvalue: total,\n\t\tlength: len,\n\t};\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ulebDecode } from './uleb';\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\n\t/**\n\t * @param {Uint8Array} data Data to use as a buffer.\n\t */\n\tconstructor(data: Uint8Array) {\n\t\tthis.dataView = new DataView(data.buffer);\n\t}\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number) {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Read U8 value from the buffer and shift cursor by 1.\n\t * @returns\n\t */\n\tread8(): number {\n\t\tlet value = this.dataView.getUint8(this.bytePosition);\n\t\tthis.shift(1);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U16 value from the buffer and shift cursor by 2.\n\t * @returns\n\t */\n\tread16(): number {\n\t\tlet value = this.dataView.getUint16(this.bytePosition, true);\n\t\tthis.shift(2);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U32 value from the buffer and shift cursor by 4.\n\t * @returns\n\t */\n\tread32(): number {\n\t\tlet value = this.dataView.getUint32(this.bytePosition, true);\n\t\tthis.shift(4);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U64 value from the buffer and shift cursor by 8.\n\t * @returns\n\t */\n\tread64(): string {\n\t\tlet value1 = this.read32();\n\t\tlet value2 = this.read32();\n\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 16.\n\t */\n\tread128(): string {\n\t\tlet value1 = BigInt(this.read64());\n\t\tlet value2 = BigInt(this.read64());\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 32.\n\t * @returns\n\t */\n\tread256(): string {\n\t\tlet value1 = BigInt(this.read128());\n\t\tlet value2 = BigInt(this.read128());\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read `num` number of bytes from the buffer and shift cursor by `num`.\n\t * @param num Number of bytes to read.\n\t */\n\treadBytes(num: number): Uint8Array {\n\t\tlet start = this.bytePosition + this.dataView.byteOffset;\n\t\tlet value = new Uint8Array(this.dataView.buffer, start, num);\n\n\t\tthis.shift(num);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read ULEB value - an integer of varying size. Used for enum indexes and\n\t * vector lengths.\n\t * @returns {Number} The ULEB value.\n\t */\n\treadULEB(): number {\n\t\tlet start = this.bytePosition + this.dataView.byteOffset;\n\t\tlet buffer = new Uint8Array(this.dataView.buffer, start);\n\t\tlet { value, length } = ulebDecode(buffer);\n\n\t\tthis.shift(length);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read a BCS vector: read a length and then apply function `cb` X times\n\t * where X is the length of the vector, defined as ULEB in BCS bytes.\n\t * @param cb Callback to process elements of vector.\n\t * @returns {Array<Any>} Array of the resulting values, returned by callback.\n\t */\n\treadVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n\t\tlet length = this.readULEB();\n\t\tlet result = [];\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult.push(cb(this, i, length));\n\t\t}\n\t\treturn result;\n\t}\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB58, toB58 } from './b58';\nimport { fromB64, toB64 } from './b64';\nimport { fromHEX, toHEX } from './hex';\nimport { Encoding } from './types';\n\n/**\n * Encode data with either `hex` or `base64`.\n *\n * @param {Uint8Array} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {String} Encoded value.\n */\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn toB58(data);\n\t\tcase 'base64':\n\t\t\treturn toB64(data);\n\t\tcase 'hex':\n\t\t\treturn toHEX(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\n/**\n * Decode either `base64` or `hex` data.\n *\n * @param {String} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {Uint8Array} Encoded value.\n */\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn fromB58(data);\n\t\tcase 'base64':\n\t\t\treturn fromB64(data);\n\t\tcase 'hex':\n\t\t\treturn fromHEX(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\nexport function splitGenericParameters(\n\tstr: string,\n\tgenericSeparators: [string, string] = ['<', '>'],\n) {\n\tconst [left, right] = genericSeparators;\n\tconst tok = [];\n\tlet word = '';\n\tlet nestedAngleBrackets = 0;\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst char = str[i];\n\t\tif (char === left) {\n\t\t\tnestedAngleBrackets++;\n\t\t}\n\t\tif (char === right) {\n\t\t\tnestedAngleBrackets--;\n\t\t}\n\t\tif (nestedAngleBrackets === 0 && char === ',') {\n\t\t\ttok.push(word.trim());\n\t\t\tword = '';\n\t\t\tcontinue;\n\t\t}\n\t\tword += char;\n\t}\n\n\ttok.push(word.trim());\n\n\treturn tok;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Encoding } from './types';\nimport { ulebEncode } from './uleb';\nimport { encodeStr } from './utils';\n\nexport interface BcsWriterOptions {\n\t/** The initial size (in bytes) of the buffer tht will be allocated */\n\tsize?: number;\n\t/** The maximum size (in bytes) that the buffer is allowed to grow to */\n\tmaxSize?: number;\n\t/** The amount of bytes that will be allocated whenever additional memory is required */\n\tallocateSize?: number;\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport class BcsWriter {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\tprivate size: number;\n\tprivate maxSize: number;\n\tprivate allocateSize: number;\n\n\tconstructor({ size = 1024, maxSize, allocateSize = 1024 }: BcsWriterOptions = {}) {\n\t\tthis.size = size;\n\t\tthis.maxSize = maxSize || size;\n\t\tthis.allocateSize = allocateSize;\n\t\tthis.dataView = new DataView(new ArrayBuffer(size));\n\t}\n\n\tprivate ensureSizeOrGrow(bytes: number) {\n\t\tconst requiredSize = this.bytePosition + bytes;\n\t\tif (requiredSize > this.size) {\n\t\t\tconst nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n\t\t\tif (requiredSize > nextSize) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.size = nextSize;\n\t\t\tconst nextBuffer = new ArrayBuffer(this.size);\n\t\t\tnew Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n\t\t\tthis.dataView = new DataView(nextBuffer);\n\t\t}\n\t}\n\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number): this {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U8 value into a buffer and shift cursor position by 1.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite8(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(1);\n\t\tthis.dataView.setUint8(this.bytePosition, Number(value));\n\t\treturn this.shift(1);\n\t}\n\t/**\n\t * Write a U16 value into a buffer and shift cursor position by 2.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite16(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(2);\n\t\tthis.dataView.setUint16(this.bytePosition, Number(value), true);\n\t\treturn this.shift(2);\n\t}\n\t/**\n\t * Write a U32 value into a buffer and shift cursor position by 4.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite32(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(4);\n\t\tthis.dataView.setUint32(this.bytePosition, Number(value), true);\n\t\treturn this.shift(4);\n\t}\n\t/**\n\t * Write a U64 value into a buffer and shift cursor position by 8.\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite64(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U128 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite128(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U256 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite256(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a ULEB value into a buffer and shift cursor position by number of bytes\n\t * written.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twriteULEB(value: number): this {\n\t\tulebEncode(value).forEach((el) => this.write8(el));\n\t\treturn this;\n\t}\n\t/**\n\t * Write a vector into a buffer by first writing the vector length and then calling\n\t * a callback on each passed value.\n\t *\n\t * @param {Array<Any>} vector Array of elements to write.\n\t * @param {WriteVecCb} cb Callback to call on each element of the vector.\n\t * @returns {this}\n\t */\n\twriteVec(vector: any[], cb: (writer: BcsWriter, el: any, i: number, len: number) => void): this {\n\t\tthis.writeULEB(vector.length);\n\t\tArray.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds support for iterations over the object.\n\t * @returns {Uint8Array}\n\t */\n\t*[Symbol.iterator](): Iterator<number, Iterable<number>> {\n\t\tfor (let i = 0; i < this.bytePosition; i++) {\n\t\t\tyield this.dataView.getUint8(i);\n\t\t}\n\t\treturn this.toBytes();\n\t}\n\n\t/**\n\t * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n\t * @returns {Uint8Array} Resulting bcs.\n\t */\n\ttoBytes(): Uint8Array {\n\t\treturn new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n\t}\n\n\t/**\n\t * Represent data as 'hex' or 'base64'\n\t * @param encoding Encoding to use: 'base64' or 'hex'\n\t */\n\ttoString(encoding: Encoding): string {\n\t\treturn encodeStr(this.toBytes(), encoding);\n\t}\n}\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n\tlet result = new Uint8Array(size);\n\tlet i = 0;\n\twhile (bigint > 0) {\n\t\tresult[i] = Number(bigint % BigInt(256));\n\t\tbigint = bigint / BigInt(256);\n\t\ti += 1;\n\t}\n\treturn result;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB58 } from './b58';\nimport { toB64 } from './b64';\nimport { toHEX } from './hex';\nimport { BcsReader } from './reader';\nimport { ulebEncode } from './uleb';\nimport { BcsWriter, BcsWriterOptions } from './writer';\n\nexport interface BcsTypeOptions<T, Input = T> {\n\tname?: string;\n\tvalidate?: (value: Input) => void;\n}\n\nexport class BcsType<T, Input = T> {\n\t$inferType!: T;\n\t$inferInput!: Input;\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserializedSize: (value: Input, options?: BcsWriterOptions) => number | null;\n\tvalidate: (value: Input) => void;\n\t#write: (value: Input, writer: BcsWriter) => void;\n\t#serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\n\tconstructor(\n\t\toptions: {\n\t\t\tname: string;\n\t\t\tread: (reader: BcsReader) => T;\n\t\t\twrite: (value: Input, writer: BcsWriter) => void;\n\t\t\tserialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n\t\t\tserializedSize?: (value: Input) => number | null;\n\t\t\tvalidate?: (value: Input) => void;\n\t\t} & BcsTypeOptions<T, Input>,\n\t) {\n\t\tthis.name = options.name;\n\t\tthis.read = options.read;\n\t\tthis.serializedSize = options.serializedSize ?? (() => null);\n\t\tthis.#write = options.write;\n\t\tthis.#serialize =\n\t\t\toptions.serialize ??\n\t\t\t((value, options) => {\n\t\t\t\tconst writer = new BcsWriter({ size: this.serializedSize(value) ?? undefined, ...options });\n\t\t\t\tthis.#write(value, writer);\n\t\t\t\treturn writer.toBytes();\n\t\t\t});\n\n\t\tthis.validate = options.validate ?? (() => {});\n\t}\n\n\twrite(value: Input, writer: BcsWriter) {\n\t\tthis.validate(value);\n\t\tthis.#write(value, writer);\n\t}\n\n\tserialize(value: Input, options?: BcsWriterOptions) {\n\t\tthis.validate(value);\n\t\treturn new SerializedBcs(this, this.#serialize(value, options));\n\t}\n\n\tparse(bytes: Uint8Array): T {\n\t\tconst reader = new BcsReader(bytes);\n\t\treturn this.read(reader);\n\t}\n\n\ttransform<T2, Input2>({\n\t\tname,\n\t\tinput,\n\t\toutput,\n\t}: {\n\t\tinput: (val: Input2) => Input;\n\t\toutput: (value: T) => T2;\n\t} & BcsTypeOptions<T2, Input2>) {\n\t\treturn new BcsType<T2, Input2>({\n\t\t\tname: name ?? this.name,\n\t\t\tread: (reader) => output(this.read(reader)),\n\t\t\twrite: (value, writer) => this.#write(input(value), writer),\n\t\t\tserializedSize: (value) => this.serializedSize(input(value)),\n\t\t\tserialize: (value, options) => this.#serialize(input(value), options),\n\t\t\tvalidate: (value) => this.validate(input(value)),\n\t\t});\n\t}\n}\n\nconst SERIALIZED_BCS_BRAND = Symbol.for('@mysten/serialized-bcs');\nexport function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown> {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[SERIALIZED_BCS_BRAND] === true;\n}\n\nexport class SerializedBcs<T, Input = T> {\n\t#schema: BcsType<T, Input>;\n\t#bytes: Uint8Array;\n\n\t// Used to brand SerializedBcs so that they can be identified, even between multiple copies\n\t// of the @mysten/bcs package are installed\n\tget [SERIALIZED_BCS_BRAND]() {\n\t\treturn true;\n\t}\n\n\tconstructor(type: BcsType<T, Input>, schema: Uint8Array) {\n\t\tthis.#schema = type;\n\t\tthis.#bytes = schema;\n\t}\n\n\ttoBytes() {\n\t\treturn this.#bytes;\n\t}\n\n\ttoHex() {\n\t\treturn toHEX(this.#bytes);\n\t}\n\n\ttoBase64() {\n\t\treturn toB64(this.#bytes);\n\t}\n\n\ttoBase58() {\n\t\treturn toB58(this.#bytes);\n\t}\n\n\tparse() {\n\t\treturn this.#schema.parse(this.#bytes);\n\t}\n}\n\nexport function fixedSizeBcsType<T, Input = T>({\n\tsize,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\tread: (reader: BcsReader) => T;\n\twrite: (value: Input, writer: BcsWriter) => void;\n} & BcsTypeOptions<T, Input>) {\n\treturn new BcsType<T, Input>({\n\t\t...options,\n\t\tserializedSize: () => size,\n\t});\n}\n\nexport function uIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${8 | 16 | 32}`;\n\twriteMethod: `write${8 | 16 | 32}`;\n\tmaxValue: number;\n} & BcsTypeOptions<number, number>) {\n\treturn fixedSizeBcsType<number>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](value),\n\t\tvalidate: (value) => {\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function bigUIntBcsType({\n\treadMethod,\n\twriteMethod,\n\t...options\n}: {\n\tname: string;\n\tsize: number;\n\treadMethod: `read${64 | 128 | 256}`;\n\twriteMethod: `write${64 | 128 | 256}`;\n\tmaxValue: bigint;\n} & BcsTypeOptions<string, string | number | bigint>) {\n\treturn fixedSizeBcsType<string, string | number | bigint>({\n\t\t...options,\n\t\tread: (reader) => reader[readMethod](),\n\t\twrite: (value, writer) => writer[writeMethod](BigInt(value)),\n\t\tvalidate: (val) => {\n\t\t\tconst value = BigInt(val);\n\t\t\tif (value < 0 || value > options.maxValue) {\n\t\t\t\tthrow new TypeError(\n\t\t\t\t\t`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function dynamicSizeBcsType<T, Input = T>({\n\tserialize,\n\t...options\n}: {\n\tname: string;\n\tread: (reader: BcsReader) => T;\n\tserialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;\n} & BcsTypeOptions<T, Input>) {\n\tconst type = new BcsType<T, Input>({\n\t\t...options,\n\t\tserialize,\n\t\twrite: (value, writer) => {\n\t\t\tfor (const byte of type.serialize(value).toBytes()) {\n\t\t\t\twriter.write8(byte);\n\t\t\t}\n\t\t},\n\t});\n\n\treturn type;\n}\n\nexport function stringLikeBcsType({\n\ttoBytes,\n\tfromBytes,\n\t...options\n}: {\n\tname: string;\n\ttoBytes: (value: string) => Uint8Array;\n\tfromBytes: (bytes: Uint8Array) => string;\n\tserializedSize?: (value: string) => number | null;\n} & BcsTypeOptions<string>) {\n\treturn new BcsType<string>({\n\t\t...options,\n\t\tread: (reader) => {\n\t\t\tconst length = reader.readULEB();\n\t\t\tconst bytes = reader.readBytes(length);\n\n\t\t\treturn fromBytes(bytes);\n\t\t},\n\t\twrite: (hex, writer) => {\n\t\t\tconst bytes = toBytes(hex);\n\t\t\twriter.writeULEB(bytes.length);\n\t\t\tfor (let i = 0; i < bytes.length; i++) {\n\t\t\t\twriter.write8(bytes[i]);\n\t\t\t}\n\t\t},\n\t\tserialize: (value) => {\n\t\t\tconst bytes = toBytes(value);\n\t\t\tconst size = ulebEncode(bytes.length);\n\t\t\tconst result = new Uint8Array(size.length + bytes.length);\n\t\t\tresult.set(size, 0);\n\t\t\tresult.set(bytes, size.length);\n\n\t\t\treturn result;\n\t\t},\n\t\tvalidate: (value) => {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n\t\t\t}\n\t\t\toptions.validate?.(value);\n\t\t},\n\t});\n}\n\nexport function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>) {\n\tlet lazyType: BcsType<T, Input> | null = null;\n\tfunction getType() {\n\t\tif (!lazyType) {\n\t\t\tlazyType = cb();\n\t\t}\n\t\treturn lazyType;\n\t}\n\n\treturn new BcsType<T, Input>({\n\t\tname: 'lazy' as never,\n\t\tread: (data) => getType().read(data),\n\t\tserializedSize: (value) => getType().serializedSize(value),\n\t\twrite: (value, writer) => getType().write(value, writer),\n\t\tserialize: (value, options) => getType().serialize(value, options).toBytes(),\n\t});\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n\tBcsType,\n\tBcsTypeOptions,\n\tbigUIntBcsType,\n\tdynamicSizeBcsType,\n\tfixedSizeBcsType,\n\tlazyBcsType,\n\tstringLikeBcsType,\n\tuIntBcsType,\n} from './bcs-type.js';\nimport { GenericPlaceholder, ReplaceBcsGenerics } from './types.js';\nimport { ulebEncode } from './uleb.js';\n\nexport const bcs = {\n\t/**\n\t * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n\t * @example\n\t * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n\t */\n\tu8(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u8',\n\t\t\treadMethod: 'read8',\n\t\t\twriteMethod: 'write8',\n\t\t\tsize: 1,\n\t\t\tmaxValue: 2 ** 8 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n\t * @example\n\t * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n\t */\n\tu16(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u16',\n\t\t\treadMethod: 'read16',\n\t\t\twriteMethod: 'write16',\n\t\t\tsize: 2,\n\t\t\tmaxValue: 2 ** 16 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n\t * @example\n\t * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n\t */\n\tu32(options?: BcsTypeOptions<number>) {\n\t\treturn uIntBcsType({\n\t\t\tname: 'u32',\n\t\t\treadMethod: 'read32',\n\t\t\twriteMethod: 'write32',\n\t\t\tsize: 4,\n\t\t\tmaxValue: 2 ** 32 - 1,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n\t * @example\n\t * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n\t */\n\tu64(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u64',\n\t\t\treadMethod: 'read64',\n\t\t\twriteMethod: 'write64',\n\t\t\tsize: 8,\n\t\t\tmaxValue: 2n ** 64n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n\t * @example\n\t * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu128(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u128',\n\t\t\treadMethod: 'read128',\n\t\t\twriteMethod: 'write128',\n\t\t\tsize: 16,\n\t\t\tmaxValue: 2n ** 128n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n\t * @example\n\t * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n\t */\n\tu256(options?: BcsTypeOptions<string, number | bigint | string>) {\n\t\treturn bigUIntBcsType({\n\t\t\tname: 'u256',\n\t\t\treadMethod: 'read256',\n\t\t\twriteMethod: 'write256',\n\t\t\tsize: 32,\n\t\t\tmaxValue: 2n ** 256n - 1n,\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write boolean values.\n\t * @example\n\t * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n\t */\n\tbool(options?: BcsTypeOptions<boolean>) {\n\t\treturn fixedSizeBcsType<boolean>({\n\t\t\tname: 'bool',\n\t\t\tsize: 1,\n\t\t\tread: (reader) => reader.read8() === 1,\n\t\t\twrite: (value, writer) => writer.write8(value ? 1 : 0),\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'boolean') {\n\t\t\t\t\tthrow new TypeError(`Expected boolean, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n\t * @example\n\t *\n\t */\n\tuleb128(options?: BcsTypeOptions<number>) {\n\t\treturn dynamicSizeBcsType<number>({\n\t\t\tname: 'uleb128',\n\t\t\tread: (reader) => reader.readULEB(),\n\t\t\tserialize: (value) => {\n\t\t\t\treturn Uint8Array.from(ulebEncode(value));\n\t\t\t},\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a fixed length byte array\n\t * @param size The number of bytes this types represents\n\t * @example\n\t * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n\t */\n\tbytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>) {\n\t\treturn fixedSizeBcsType<Uint8Array>({\n\t\t\tname: `bytes[${size}]`,\n\t\t\tsize,\n\t\t\tread: (reader) => reader.readBytes(size),\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\twriter.write8(value[i] ?? 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n\t * @example\n\t * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n\t */\n\tstring(options?: BcsTypeOptions<string>) {\n\t\treturn stringLikeBcsType({\n\t\t\tname: 'string',\n\t\t\ttoBytes: (value) => new TextEncoder().encode(value),\n\t\t\tfromBytes: (bytes) => new TextDecoder().decode(bytes),\n\t\t\t...options,\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType that represents a fixed length array of a given type\n\t * @param size The number of elements in the array\n\t * @param type The BcsType of each element in the array\n\t * @example\n\t * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n\t */\n\tfixedArray<T, Input>(\n\t\tsize: number,\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `${type.name}[${size}]`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: T[] = new Array(size);\n\t\t\t\tfor (let i = 0; i < size; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== size) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${size}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an optional value\n\t * @param type The BcsType of the optional value\n\t * @example\n\t * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n\t * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n\t */\n\toption<T, Input>(type: BcsType<T, Input>) {\n\t\treturn bcs\n\t\t\t.enum(`Option<${type.name}>`, {\n\t\t\t\tNone: null,\n\t\t\t\tSome: type,\n\t\t\t})\n\t\t\t.transform({\n\t\t\t\tinput: (value: Input | null | undefined) => {\n\t\t\t\t\tif (value == null) {\n\t\t\t\t\t\treturn { None: true };\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { Some: value };\n\t\t\t\t},\n\t\t\t\toutput: (value) => {\n\t\t\t\t\tif ('Some' in value) {\n\t\t\t\t\t\treturn value.Some;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a variable length vector of a given type\n\t * @param type The BcsType of each element in the vector\n\t *\n\t * @example\n\t * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n\t */\n\tvector<T, Input>(\n\t\ttype: BcsType<T, Input>,\n\t\toptions?: BcsTypeOptions<T[], Iterable<Input> & { length: number }>,\n\t) {\n\t\treturn new BcsType<T[], Iterable<Input> & { length: number }>({\n\t\t\tname: `vector<${type.name}>`,\n\t\t\tread: (reader) => {\n\t\t\t\tconst length = reader.readULEB();\n\t\t\t\tconst result: T[] = new Array(length);\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tresult[i] = type.read(reader);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\twriter.writeULEB(value.length);\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\ttype.write(item, writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!('length' in value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a tuple of a given set of types\n\t * @param types The BcsTypes for each element in the tuple\n\t *\n\t * @example\n\t * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n\t * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n\t */\n\ttuple<const Types extends readonly BcsType<any>[]>(\n\t\ttypes: Types,\n\t\toptions?: BcsTypeOptions<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>,\n\t) {\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t-readonly [K in keyof Types]: Types[K] extends BcsType<infer T, any> ? T : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof Types]: Types[K] extends BcsType<any, infer T> ? T : never;\n\t\t\t}\n\t\t>({\n\t\t\tname: `(${types.map((t) => t.name).join(', ')})`,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\tconst size = types[i].serializedSize(values[i]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: unknown[] = [];\n\t\t\t\tfor (const type of types) {\n\t\t\t\t\tresult.push(type.read(reader));\n\t\t\t\t}\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\t\t\ttypes[i].write(value[i], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\tthrow new TypeError(`Expected array, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t\tif (value.length !== types.length) {\n\t\t\t\t\tthrow new TypeError(`Expected array of length ${types.length}, found ${value.length}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a struct of a given set of fields\n\t * @param name The name of the struct\n\t * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n\t *\n\t * @example\n\t * const struct = bcs.struct('MyStruct', {\n\t *  a: bcs.u8(),\n\t *  b: bcs.string(),\n\t * })\n\t * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t */\n\tstruct<T extends Record<string, BcsType<any>>>(\n\t\tname: string,\n\t\tfields: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t\t}\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(fields);\n\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? U : never;\n\t\t\t},\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U> ? U : never;\n\t\t\t}\n\t\t>({\n\t\t\tname,\n\t\t\tserializedSize: (values) => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tconst size = type.serializedSize(values[field]);\n\t\t\t\t\tif (size == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\ttotal += size;\n\t\t\t\t}\n\n\t\t\t\treturn total;\n\t\t\t},\n\t\t\tread: (reader) => {\n\t\t\t\tconst result: Record<string, unknown> = {};\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\tresult[field] = type.read(reader);\n\t\t\t\t}\n\n\t\t\t\treturn result as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tfor (const [field, type] of canonicalOrder) {\n\t\t\t\t\ttype.write(value[field], writer);\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing an enum of a given set of options\n\t * @param name The name of the enum\n\t * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n\t * null can be used to represent a variant with no data.\n\t *\n\t * @example\n\t * const enum = bcs.enum('MyEnum', {\n\t *   A: bcs.u8(),\n\t *   B: bcs.string(),\n\t *   C: null,\n\t * })\n\t * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n\t * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n\t * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n\t */\n\tenum<T extends Record<string, BcsType<any> | null>>(\n\t\tname: string,\n\t\tvalues: T,\n\t\toptions?: Omit<\n\t\t\tBcsTypeOptions<\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any>\n\t\t\t\t\t\t? { [K2 in K]: U }\n\t\t\t\t\t\t: { [K2 in K]: true };\n\t\t\t\t}[keyof T],\n\t\t\t\t{\n\t\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U>\n\t\t\t\t\t\t? { [K2 in K]: U }\n\t\t\t\t\t\t: { [K2 in K]: unknown };\n\t\t\t\t}[keyof T]\n\t\t\t>,\n\t\t\t'name'\n\t\t>,\n\t) {\n\t\tconst canonicalOrder = Object.entries(values as object);\n\t\treturn new BcsType<\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<infer U, any> ? { [K2 in K]: U } : { [K2 in K]: true };\n\t\t\t}[keyof T],\n\t\t\t{\n\t\t\t\t[K in keyof T]: T[K] extends BcsType<any, infer U>\n\t\t\t\t\t? { [K2 in K]: U }\n\t\t\t\t\t: { [K2 in K]: unknown };\n\t\t\t}[keyof T]\n\t\t>({\n\t\t\tname,\n\t\t\tread: (reader) => {\n\t\t\t\tconst index = reader.readULEB();\n\t\t\t\tconst [name, type] = canonicalOrder[index];\n\t\t\t\treturn {\n\t\t\t\t\t[name]: type?.read(reader) ?? true,\n\t\t\t\t} as never;\n\t\t\t},\n\t\t\twrite: (value, writer) => {\n\t\t\t\tconst [name, val] = Object.entries(value)[0];\n\t\t\t\tfor (let i = 0; i < canonicalOrder.length; i++) {\n\t\t\t\t\tconst [optionName, optionType] = canonicalOrder[i];\n\t\t\t\t\tif (optionName === name) {\n\t\t\t\t\t\twriter.writeULEB(i);\n\t\t\t\t\t\toptionType?.write(val, writer);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t...options,\n\t\t\tvalidate: (value) => {\n\t\t\t\toptions?.validate?.(value);\n\t\t\t\tif (typeof value !== 'object' || value == null) {\n\t\t\t\t\tthrow new TypeError(`Expected object, found ${typeof value}`);\n\t\t\t\t}\n\n\t\t\t\tconst keys = Object.keys(value);\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tthrow new TypeError(`Expected object with one key, found ${keys.length}`);\n\t\t\t\t}\n\n\t\t\t\tconst [name] = keys;\n\n\t\t\t\tif (!Object.hasOwn(values, name)) {\n\t\t\t\t\tthrow new TypeError(`Invalid enum variant ${name}`);\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a BcsType representing a map of a given key and value type\n\t * @param keyType The BcsType of the key\n\t * @param valueType The BcsType of the value\n\t * @example\n\t * const map = bcs.map(bcs.u8(), bcs.string())\n\t * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n\t */\n\tmap<K, V, InputK = K, InputV = V>(keyType: BcsType<K, InputK>, valueType: BcsType<V, InputV>) {\n\t\treturn bcs.vector(bcs.tuple([keyType, valueType])).transform({\n\t\t\tname: `Map<${keyType.name}, ${valueType.name}>`,\n\t\t\tinput: (value: Map<InputK, InputV>) => {\n\t\t\t\treturn [...value.entries()];\n\t\t\t},\n\t\t\toutput: (value) => {\n\t\t\t\tconst result = new Map<K, V>();\n\t\t\t\tfor (const [key, val] of value) {\n\t\t\t\t\tresult.set(key, val);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t});\n\t},\n\n\t/**\n\t * Creates a helper function representing a generic type. This method returns\n\t * a function that can be used to create concrete version of the generic type.\n\t * @param names The names of the generic parameters\n\t * @param cb A callback that returns the generic type\n\t * @example\n\t * const MyStruct = bcs.generic(['T'], (T) => bcs.struct('MyStruct', { inner: T }))\n\t * MyStruct(bcs.u8()).serialize({ inner: 1 }).toBytes() // Uint8Array [ 1 ]\n\t * MyStruct(bcs.string()).serialize({ inner: 'a' }).toBytes() // Uint8Array [ 1, 97 ]\n\t */\n\tgeneric<const Names extends readonly string[], const Type extends BcsType<any>>(\n\t\tnames: Names,\n\t\tcb: (...types: { [K in keyof Names]: BcsType<GenericPlaceholder<Names[K]>> }) => Type,\n\t): <T extends { [K in keyof Names]: BcsType<any> }>(\n\t\t...types: T\n\t) => ReplaceBcsGenerics<Type, Names, T> {\n\t\treturn (...types) => {\n\t\t\treturn cb(...types).transform({\n\t\t\t\tname: `${cb.name}<${types.map((t) => t.name).join(', ')}>`,\n\t\t\t\tinput: (value) => value,\n\t\t\t\toutput: (value) => value,\n\t\t\t}) as never;\n\t\t};\n\t},\n\n\t/**\n\t * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n\t * @param cb A callback that returns the BcsType\n\t */\n\tlazy<T extends BcsType<any>>(cb: () => T): T {\n\t\treturn lazyBcsType(cb) as T;\n\t},\n};\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB58, toB58 } from './b58.js';\nimport { fromB64, toB64 } from './b64.js';\nimport { BcsType } from './bcs-type.js';\nimport { fromHEX, toHEX } from './hex.js';\nimport { BcsReader } from './reader.js';\nimport { Encoding } from './types.js';\nimport { decodeStr, splitGenericParameters } from './utils.js';\nimport { BcsWriter, BcsWriterOptions } from './writer.js';\n\n/**\n * Allows for array definitions for names.\n * @example\n * ```\n * bcs.registerStructType(['vector', BCS.STRING], ...);\n * // equals\n * bcs.registerStructType('vector<string>', ...);\n * ```\n */\nexport type TypeName = string | [string, ...(TypeName | string)[]];\n\nconst SUI_ADDRESS_LENGTH = 32;\n\nexport interface TypeInterface {\n\tencode: (\n\t\tself: BCS,\n\t\tdata: any,\n\t\toptions: BcsWriterOptions | undefined,\n\t\ttypeParams: TypeName[],\n\t) => BcsWriter;\n\tdecode: (self: BCS, data: Uint8Array, typeParams: TypeName[]) => any;\n\n\t_encodeRaw: (\n\t\twriter: BcsWriter,\n\t\tdata: any,\n\t\ttypeParams: TypeName[],\n\t\ttypeMap: { [key: string]: TypeName },\n\t) => BcsWriter;\n\t_decodeRaw: (\n\t\treader: BcsReader,\n\t\ttypeParams: TypeName[],\n\t\ttypeMap: { [key: string]: TypeName },\n\t) => any;\n}\n\n/**\n * Struct type definition. Used as input format in BcsConfig.types\n * as well as an argument type for `bcs.registerStructType`.\n */\nexport type StructTypeDefinition = {\n\t[key: string]: TypeName | StructTypeDefinition;\n};\n\n/**\n * Enum type definition. Used as input format in BcsConfig.types\n * as well as an argument type for `bcs.registerEnumType`.\n *\n * Value can be either `string` when invariant has a type or `null`\n * when invariant is empty.\n *\n * @example\n * bcs.registerEnumType('Option<T>', {\n *   some: 'T',\n *   none: null\n * });\n */\nexport type EnumTypeDefinition = {\n\t[key: string]: TypeName | StructTypeDefinition | null;\n};\n\n/**\n * Configuration that is passed into BCS constructor.\n */\nexport type BcsConfig = {\n\t/**\n\t * Defines type name for the vector / array type.\n\t * In Move: `vector<T>` or `vector`.\n\t */\n\tvectorType: string;\n\t/**\n\t * Address length. Varies depending on a platform and\n\t * has to be specified for the `address` type.\n\t */\n\taddressLength: number;\n\n\t/**\n\t * Custom encoding for address. Supported values are\n\t * either 'hex' or 'base64'.\n\t */\n\taddressEncoding?: 'hex' | 'base64';\n\t/**\n\t * Opening and closing symbol for type parameters. Can be\n\t * any pair of symbols (eg `['(', ')']`); default value follows\n\t * Rust and Move: `<` and `>`.\n\t */\n\tgenericSeparators?: [string, string];\n\t/**\n\t * Type definitions for the BCS. This field allows spawning\n\t * BCS instance from JSON or another prepared configuration.\n\t * Optional.\n\t */\n\ttypes?: {\n\t\tstructs?: { [key: string]: StructTypeDefinition };\n\t\tenums?: { [key: string]: EnumTypeDefinition };\n\t\taliases?: { [key: string]: string };\n\t};\n\t/**\n\t * Whether to auto-register primitive types on launch.\n\t */\n\twithPrimitives?: boolean;\n};\n\n/**\n * BCS implementation for Move types and few additional built-ins.\n */\nexport class BCS {\n\t// Predefined types constants\n\tstatic readonly U8 = 'u8';\n\tstatic readonly U16 = 'u16';\n\tstatic readonly U32 = 'u32';\n\tstatic readonly U64 = 'u64';\n\tstatic readonly U128 = 'u128';\n\tstatic readonly U256 = 'u256';\n\tstatic readonly BOOL = 'bool';\n\tstatic readonly VECTOR = 'vector';\n\tstatic readonly ADDRESS = 'address';\n\tstatic readonly STRING = 'string';\n\tstatic readonly HEX = 'hex-string';\n\tstatic readonly BASE58 = 'base58-string';\n\tstatic readonly BASE64 = 'base64-string';\n\n\t/**\n\t * Map of kind `TypeName => TypeInterface`. Holds all\n\t * callbacks for (de)serialization of every registered type.\n\t *\n\t * If the value stored is a string, it is treated as an alias.\n\t */\n\tpublic types: Map<string, TypeInterface | string> = new Map();\n\n\t/**\n\t * Stored BcsConfig for the current instance of BCS.\n\t */\n\tprotected schema: BcsConfig;\n\n\t/**\n\t * Count temp keys to generate a new one when requested.\n\t */\n\tprotected counter: number = 0;\n\n\t/**\n\t * Name of the key to use for temporary struct definitions.\n\t * Returns a temp key + index (for a case when multiple temp\n\t * structs are processed).\n\t */\n\tprivate tempKey() {\n\t\treturn `bcs-struct-${++this.counter}`;\n\t}\n\n\t/**\n\t * Construct a BCS instance with a prepared schema.\n\t *\n\t * @param schema A prepared schema with type definitions\n\t * @param withPrimitives Whether to register primitive types by default\n\t */\n\tconstructor(schema: BcsConfig | BCS) {\n\t\t// if BCS instance is passed -> clone its schema\n\t\tif (schema instanceof BCS) {\n\t\t\tthis.schema = schema.schema;\n\t\t\tthis.types = new Map(schema.types);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.schema = schema;\n\n\t\t// Register address type under key 'address'.\n\t\tthis.registerAddressType(BCS.ADDRESS, schema.addressLength, schema.addressEncoding);\n\t\tthis.registerVectorType(schema.vectorType);\n\n\t\t// Register struct types if they were passed.\n\t\tif (schema.types && schema.types.structs) {\n\t\t\tfor (let name of Object.keys(schema.types.structs)) {\n\t\t\t\tthis.registerStructType(name, schema.types.structs[name]);\n\t\t\t}\n\t\t}\n\n\t\t// Register enum types if they were passed.\n\t\tif (schema.types && schema.types.enums) {\n\t\t\tfor (let name of Object.keys(schema.types.enums)) {\n\t\t\t\tthis.registerEnumType(name, schema.types.enums[name]);\n\t\t\t}\n\t\t}\n\n\t\t// Register aliases if they were passed.\n\t\tif (schema.types && schema.types.aliases) {\n\t\t\tfor (let name of Object.keys(schema.types.aliases)) {\n\t\t\t\tthis.registerAlias(name, schema.types.aliases[name]);\n\t\t\t}\n\t\t}\n\n\t\tif (schema.withPrimitives !== false) {\n\t\t\tregisterPrimitives(this);\n\t\t}\n\t}\n\n\t/**\n\t * Serialize data into bcs.\n\t *\n\t * @example\n\t * bcs.registerVectorType('vector<u8>', 'u8');\n\t *\n\t * let serialized = BCS\n\t *   .set('vector<u8>', [1,2,3,4,5,6])\n\t *   .toBytes();\n\t *\n\t * console.assert(toHex(serialized) === '06010203040506');\n\t *\n\t * @param type Name of the type to serialize (must be registered) or a struct type.\n\t * @param data Data to serialize.\n\t * @param size Serialization buffer size. Default 1024 = 1KB.\n\t * @return A BCS reader instance. Usually you'd want to call `.toBytes()`\n\t */\n\tpublic ser(\n\t\ttype: TypeName | StructTypeDefinition,\n\t\tdata: any,\n\t\toptions?: BcsWriterOptions,\n\t): BcsWriter {\n\t\tif (typeof type === 'string' || Array.isArray(type)) {\n\t\t\tconst { name, params } = this.parseTypeName(type);\n\t\t\treturn this.getTypeInterface(name).encode(this, data, options, params as string[]);\n\t\t}\n\n\t\t// Quick serialization without registering the type in the main struct.\n\t\tif (typeof type === 'object') {\n\t\t\tconst key = this.tempKey();\n\t\t\tconst temp = new BCS(this);\n\t\t\treturn temp.registerStructType(key, type).ser(key, data, options);\n\t\t}\n\n\t\tthrow new Error(`Incorrect type passed into the '.ser()' function. \\n${JSON.stringify(type)}`);\n\t}\n\n\t/**\n\t * Deserialize BCS into a JS type.\n\t *\n\t * @example\n\t * let num = bcs.ser('u64', '4294967295').toString('hex');\n\t * let deNum = bcs.de('u64', num, 'hex');\n\t * console.assert(deNum.toString(10) === '4294967295');\n\t *\n\t * @param type Name of the type to deserialize (must be registered) or a struct type definition.\n\t * @param data Data to deserialize.\n\t * @param encoding Optional - encoding to use if data is of type String\n\t * @return Deserialized data.\n\t */\n\tpublic de(\n\t\ttype: TypeName | StructTypeDefinition,\n\t\tdata: Uint8Array | string,\n\t\tencoding?: Encoding,\n\t): any {\n\t\tif (typeof data === 'string') {\n\t\t\tif (encoding) {\n\t\t\t\tdata = decodeStr(data, encoding);\n\t\t\t} else {\n\t\t\t\tthrow new Error('To pass a string to `bcs.de`, specify encoding');\n\t\t\t}\n\t\t}\n\n\t\t// In case the type specified is already registered.\n\t\tif (typeof type === 'string' || Array.isArray(type)) {\n\t\t\tconst { name, params } = this.parseTypeName(type);\n\t\t\treturn this.getTypeInterface(name).decode(this, data, params as string[]);\n\t\t}\n\n\t\t// Deserialize without registering a type using a temporary clone.\n\t\tif (typeof type === 'object') {\n\t\t\tconst temp = new BCS(this);\n\t\t\tconst key = this.tempKey();\n\t\t\treturn temp.registerStructType(key, type).de(key, data, encoding);\n\t\t}\n\n\t\tthrow new Error(`Incorrect type passed into the '.de()' function. \\n${JSON.stringify(type)}`);\n\t}\n\n\t/**\n\t * Check whether a `TypeInterface` has been loaded for a `type`.\n\t * @param type Name of the type to check.\n\t * @returns\n\t */\n\tpublic hasType(type: string): boolean {\n\t\treturn this.types.has(type);\n\t}\n\n\t/**\n\t * Create an alias for a type.\n\t * WARNING: this can potentially lead to recursion\n\t * @param name Alias to use\n\t * @param forType Type to reference\n\t * @returns\n\t *\n\t * @example\n\t * ```\n\t * let bcs = new BCS(getSuiMoveConfig());\n\t * bcs.registerAlias('ObjectDigest', BCS.BASE58);\n\t * let b58_digest = bcs.de('ObjectDigest', '<digest_bytes>', 'base64');\n\t * ```\n\t */\n\tpublic registerAlias(name: string, forType: string): BCS {\n\t\tthis.types.set(name, forType);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Method to register new types for BCS internal representation.\n\t * For each registered type 2 callbacks must be specified and one is optional:\n\t *\n\t * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;\n\t * - decodeCb(reader) - write a way to deserialize data with BcsReader;\n\t * - validateCb(data) - validate data - either return bool or throw an error\n\t *\n\t * @example\n\t * // our type would be a string that consists only of numbers\n\t * bcs.registerType('number_string',\n\t *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),\n\t *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8\n\t *    (value) => /[0-9]+/.test(value) // test that it has at least one digit\n\t * );\n\t * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);\n\t *\n\t * @param name\n\t * @param encodeCb Callback to encode a value.\n\t * @param decodeCb Callback to decode a value.\n\t * @param validateCb Optional validator Callback to check type before serialization.\n\t */\n\tpublic registerType(\n\t\ttypeName: TypeName,\n\t\tencodeCb: (\n\t\t\twriter: BcsWriter,\n\t\t\tdata: any,\n\t\t\ttypeParams: TypeName[],\n\t\t\ttypeMap: { [key: string]: TypeName },\n\t\t) => BcsWriter,\n\t\tdecodeCb: (\n\t\t\treader: BcsReader,\n\t\t\ttypeParams: TypeName[],\n\t\t\ttypeMap: { [key: string]: TypeName },\n\t\t) => any,\n\t\tvalidateCb: (data: any) => boolean = () => true,\n\t): BCS {\n\t\tconst { name, params: generics } = this.parseTypeName(typeName);\n\n\t\tthis.types.set(name, {\n\t\t\tencode(self: BCS, data, options: BcsWriterOptions, typeParams) {\n\t\t\t\tconst typeMap = (generics as string[]).reduce((acc: any, value: string, index) => {\n\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\n\t\t\t\t}, {});\n\n\t\t\t\treturn this._encodeRaw.call(self, new BcsWriter(options), data, typeParams, typeMap);\n\t\t\t},\n\t\t\tdecode(self: BCS, data, typeParams) {\n\t\t\t\tconst typeMap = (generics as string[]).reduce((acc: any, value: string, index) => {\n\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\n\t\t\t\t}, {});\n\n\t\t\t\treturn this._decodeRaw.call(self, new BcsReader(data), typeParams, typeMap);\n\t\t\t},\n\n\t\t\t// these methods should always be used with caution as they require pre-defined\n\t\t\t// reader and writer and mainly exist to allow multi-field (de)serialization;\n\t\t\t_encodeRaw(writer, data, typeParams, typeMap) {\n\t\t\t\tif (validateCb(data)) {\n\t\t\t\t\treturn encodeCb.call(this, writer, data, typeParams, typeMap);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(`Validation failed for type ${name}, data: ${data}`);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_decodeRaw(reader, typeParams, typeMap) {\n\t\t\t\treturn decodeCb.call(this, reader, typeParams, typeMap);\n\t\t\t},\n\t\t} as TypeInterface);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Method to register BcsType instances to the registry\n\t * Types are registered with a callback that provides BcsType instances for each generic\n\t * passed to the type.\n\t *\n\t * - createType(...generics) - Return a BcsType instance\n\t *\n\t * @example\n\t * // our type would be a string that consists only of numbers\n\t * bcs.registerType('Box<T>', (T) => {\n\t * \t\treturn bcs.struct({\n\t * \t\t\tvalue: T\n\t * \t\t});\n\t * });\n\n\t * console.log(Array.from(bcs.ser('Box<string>', '12345').toBytes()) == [5,1,2,3,4,5]);\n\t *\n\t * @param name\n\t * @param createType a Callback to create the BcsType with any passed in generics\n\t */\n\tpublic registerBcsType(\n\t\ttypeName: TypeName,\n\t\tcreateType: (...params: BcsType<any>[]) => BcsType<any>,\n\t) {\n\t\tthis.registerType(\n\t\t\ttypeName,\n\t\t\t(writer, data, typeParams) => {\n\t\t\t\tconst generics = typeParams.map(\n\t\t\t\t\t(param) =>\n\t\t\t\t\t\tnew BcsType<unknown>({\n\t\t\t\t\t\t\tname: String(param),\n\t\t\t\t\t\t\twrite: (data, writer) => {\n\t\t\t\t\t\t\t\tconst { name, params } = this.parseTypeName(param);\n\t\t\t\t\t\t\t\tconst typeInterface = this.getTypeInterface(name);\n\n\t\t\t\t\t\t\t\tconst typeMap = (params as string[]).reduce((acc: any, value: string, index) => {\n\t\t\t\t\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\n\t\t\t\t\t\t\t\t}, {});\n\n\t\t\t\t\t\t\t\treturn typeInterface._encodeRaw.call(this, writer, data, params, typeMap);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tread: () => {\n\t\t\t\t\t\t\t\tthrow new Error('Not implemented');\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t);\n\n\t\t\t\tcreateType(...generics).write(data, writer);\n\t\t\t\treturn writer;\n\t\t\t},\n\t\t\t(reader, typeParams) => {\n\t\t\t\tconst generics = typeParams.map(\n\t\t\t\t\t(param) =>\n\t\t\t\t\t\tnew BcsType<unknown>({\n\t\t\t\t\t\t\tname: String(param),\n\t\t\t\t\t\t\twrite: (data, writer) => {\n\t\t\t\t\t\t\t\tthrow new Error('Not implemented');\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tread: (reader) => {\n\t\t\t\t\t\t\t\tconst { name, params } = this.parseTypeName(param);\n\t\t\t\t\t\t\t\tconst typeInterface = this.getTypeInterface(name);\n\n\t\t\t\t\t\t\t\tconst typeMap = (params as string[]).reduce((acc: any, value: string, index) => {\n\t\t\t\t\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\n\t\t\t\t\t\t\t\t}, {});\n\n\t\t\t\t\t\t\t\treturn typeInterface._decodeRaw.call(this, reader, params, typeMap);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t);\n\n\t\t\t\treturn createType(...generics).read(reader);\n\t\t\t},\n\t\t);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Register an address type which is a sequence of U8s of specified length.\n\t * @example\n\t * bcs.registerAddressType('address', SUI_ADDRESS_LENGTH);\n\t * let addr = bcs.de('address', 'c3aca510c785c7094ac99aeaa1e69d493122444df50bb8a99dfa790c654a79af');\n\t *\n\t * @param name Name of the address type.\n\t * @param length Byte length of the address.\n\t * @param encoding Encoding to use for the address type\n\t * @returns\n\t */\n\tpublic registerAddressType(name: string, length: number, encoding: Encoding | void = 'hex'): BCS {\n\t\tswitch (encoding) {\n\t\t\tcase 'base64':\n\t\t\t\treturn this.registerType(\n\t\t\t\t\tname,\n\t\t\t\t\tfunction encodeAddress(writer, data: string) {\n\t\t\t\t\t\treturn fromB64(data).reduce((writer, el) => writer.write8(el), writer);\n\t\t\t\t\t},\n\t\t\t\t\tfunction decodeAddress(reader) {\n\t\t\t\t\t\treturn toB64(reader.readBytes(length));\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\tcase 'hex':\n\t\t\t\treturn this.registerType(\n\t\t\t\t\tname,\n\t\t\t\t\tfunction encodeAddress(writer, data: string) {\n\t\t\t\t\t\treturn fromHEX(data).reduce((writer, el) => writer.write8(el), writer);\n\t\t\t\t\t},\n\t\t\t\t\tfunction decodeAddress(reader) {\n\t\t\t\t\t\treturn toHEX(reader.readBytes(length));\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unsupported encoding! Use either hex or base64');\n\t\t}\n\t}\n\n\t/**\n\t * Register custom vector type inside the bcs.\n\t *\n\t * @example\n\t * bcs.registerVectorType('vector<T>'); // generic registration\n\t * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];\n\t * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');\n\t *\n\t * @param name Name of the type to register\n\t * @param elementType Optional name of the inner type of the vector\n\t * @return Returns self for chaining.\n\t */\n\tprivate registerVectorType(typeName: string): BCS {\n\t\tlet { name, params } = this.parseTypeName(typeName);\n\t\tif (params.length > 1) {\n\t\t\tthrow new Error('Vector can have only one type parameter; got ' + name);\n\t\t}\n\n\t\treturn this.registerType(\n\t\t\ttypeName,\n\t\t\tfunction encodeVector(\n\t\t\t\tthis: BCS,\n\t\t\t\twriter: BcsWriter,\n\t\t\t\tdata: any[],\n\t\t\t\ttypeParams: TypeName[],\n\t\t\t\ttypeMap,\n\t\t\t) {\n\t\t\t\treturn writer.writeVec(data, (writer, el) => {\n\t\t\t\t\tlet elementType: TypeName = typeParams[0];\n\t\t\t\t\tif (!elementType) {\n\t\t\t\t\t\tthrow new Error(`Incorrect number of type parameters passed a to vector '${typeName}'`);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name, params } = this.parseTypeName(elementType);\n\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\treturn this.getTypeInterface(name)._encodeRaw.call(this, writer, el, params, typeMap);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in vector; make sure you passed a generic`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\n\t\t\t\t\treturn this.getTypeInterface(innerName)._encodeRaw.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\twriter,\n\t\t\t\t\t\tel,\n\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t},\n\t\t\tfunction decodeVector(this: BCS, reader: BcsReader, typeParams, typeMap) {\n\t\t\t\treturn reader.readVec((reader) => {\n\t\t\t\t\tlet elementType: TypeName = typeParams[0];\n\t\t\t\t\tif (!elementType) {\n\t\t\t\t\t\tthrow new Error(`Incorrect number of type parameters passed to a vector '${typeName}'`);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name, params } = this.parseTypeName(elementType);\n\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\treturn this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in vector; make sure you passed a generic`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\n\t\t\t\t\treturn this.getTypeInterface(innerName)._decodeRaw.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\treader,\n\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t},\n\t\t);\n\t}\n\n\t/**\n\t * Safe method to register a custom Move struct. The first argument is a name of the\n\t * struct which is only used on the FrontEnd and has no affect on serialization results,\n\t * and the second is a struct description passed as an Object.\n\t *\n\t * The description object MUST have the same order on all of the platforms (ie in Move\n\t * or in Rust).\n\t *\n\t * @example\n\t * // Move / Rust struct\n\t * // struct Coin {\n\t * //   value: u64,\n\t * //   owner: vector<u8>, // name // Vec<u8> in Rust\n\t * //   is_locked: bool,\n\t * // }\n\t *\n\t * bcs.registerStructType('Coin', {\n\t *   value: bcs.U64,\n\t *   owner: bcs.STRING,\n\t *   is_locked: bcs.BOOL\n\t * });\n\t *\n\t * // Created in Rust with diem/bcs\n\t * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';\n\t * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array\n\t *  128, 209, 177,   5,  96,  0,  0,\n\t *    0,  14,  66, 105, 103, 32, 87,\n\t *   97, 108, 108, 101, 116, 32, 71,\n\t *  117, 121,   0\n\t * ];\n\t *\n\t * // Let's encode the value as well\n\t * let test_set = bcs.ser('Coin', {\n\t *   owner: 'Big Wallet Guy',\n\t *   value: '412412400000',\n\t *   is_locked: false,\n\t * });\n\t *\n\t * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');\n\t *\n\t * @param name Name of the type to register.\n\t * @param fields Fields of the struct. Must be in the correct order.\n\t * @return Returns BCS for chaining.\n\t */\n\tpublic registerStructType(typeName: TypeName, fields: StructTypeDefinition): BCS {\n\t\t// When an Object is passed, we register it under a new key and store it\n\t\t// in the registered type system. This way we allow nested inline definitions.\n\t\tfor (let key in fields) {\n\t\t\tlet internalName = this.tempKey();\n\t\t\tlet value = fields[key];\n\n\t\t\t// TODO: add a type guard here?\n\t\t\tif (!Array.isArray(value) && typeof value !== 'string') {\n\t\t\t\tfields[key] = internalName;\n\t\t\t\tthis.registerStructType(internalName, value as StructTypeDefinition);\n\t\t\t}\n\t\t}\n\n\t\tlet struct = Object.freeze(fields); // Make sure the order doesn't get changed\n\n\t\t// IMPORTANT: we need to store canonical order of fields for each registered\n\t\t// struct so we maintain it and allow developers to use any field ordering in\n\t\t// their code (and not cause mismatches based on field order).\n\t\tlet canonicalOrder = Object.keys(struct);\n\n\t\t// Holds generics for the struct definition. At this stage we can check that\n\t\t// generic parameter matches the one defined in the struct.\n\t\tlet { name: structName, params: generics } = this.parseTypeName(typeName);\n\n\t\t// Make sure all the types in the fields description are already known\n\t\t// and that all the field types are strings.\n\t\treturn this.registerType(\n\t\t\ttypeName,\n\t\t\tfunction encodeStruct(\n\t\t\t\tthis: BCS,\n\t\t\t\twriter: BcsWriter,\n\t\t\t\tdata: { [key: string]: any },\n\t\t\t\ttypeParams,\n\t\t\t\ttypeMap,\n\t\t\t) {\n\t\t\t\tif (!data || data.constructor !== Object) {\n\t\t\t\t\tthrow new Error(`Expected ${structName} to be an Object, got: ${data}`);\n\t\t\t\t}\n\n\t\t\t\tif (typeParams.length !== generics.length) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// follow the canonical order when serializing\n\t\t\t\tfor (let key of canonicalOrder) {\n\t\t\t\t\tif (!(key in data)) {\n\t\t\t\t\t\tthrow new Error(`Struct ${structName} requires field ${key}:${struct[key]}`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Before deserializing, read the canonical field type.\n\t\t\t\t\tconst { name: fieldType, params: fieldParams } = this.parseTypeName(\n\t\t\t\t\t\tstruct[key] as TypeName,\n\t\t\t\t\t);\n\n\t\t\t\t\t// Check whether this type is a generic defined in this struct.\n\t\t\t\t\t// If it is -> read the type parameter matching its index.\n\t\t\t\t\t// If not - tread as a regular field.\n\t\t\t\t\tif (!generics.includes(fieldType)) {\n\t\t\t\t\t\tthis.getTypeInterface(fieldType)._encodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\twriter,\n\t\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\t\tfieldParams,\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst paramIdx = generics.indexOf(fieldType);\n\t\t\t\t\t\tlet { name, params } = this.parseTypeName(typeParams[paramIdx]);\n\n\t\t\t\t\t\t// If the type from the type parameters already exists\n\t\t\t\t\t\t// and known -> proceed with type decoding.\n\t\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\t\tthis.getTypeInterface(name)._encodeRaw.call(\n\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\twriter,\n\t\t\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\t\t\tparams as string[],\n\t\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Alternatively, if it's a global generic parameter...\n\t\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\t\t\t\t\t\tthis.getTypeInterface(innerName)._encodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\twriter,\n\t\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn writer;\n\t\t\t},\n\t\t\tfunction decodeStruct(this: BCS, reader: BcsReader, typeParams, typeMap) {\n\t\t\t\tif (typeParams.length !== generics.length) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet result: { [key: string]: any } = {};\n\t\t\t\tfor (let key of canonicalOrder) {\n\t\t\t\t\tconst { name: fieldName, params: fieldParams } = this.parseTypeName(\n\t\t\t\t\t\tstruct[key] as TypeName,\n\t\t\t\t\t);\n\n\t\t\t\t\t// if it's not a generic\n\t\t\t\t\tif (!generics.includes(fieldName)) {\n\t\t\t\t\t\tresult[key] = this.getTypeInterface(fieldName)._decodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\treader,\n\t\t\t\t\t\t\tfieldParams as string[],\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst paramIdx = generics.indexOf(fieldName);\n\t\t\t\t\t\tlet { name, params } = this.parseTypeName(typeParams[paramIdx]);\n\n\t\t\t\t\t\t// If the type from the type parameters already exists\n\t\t\t\t\t\t// and known -> proceed with type decoding.\n\t\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\t\tresult[key] = this.getTypeInterface(name)._decodeRaw.call(\n\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\treader,\n\t\t\t\t\t\t\t\tparams,\n\t\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\t\t\t\t\t\tresult[key] = this.getTypeInterface(innerName)._decodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\treader,\n\t\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t);\n\t}\n\n\t/**\n\t * Safe method to register custom enum type where each invariant holds the value of another type.\n\t * @example\n\t * bcs.registerStructType('Coin', { value: 'u64' });\n\t * bcs.registerEnumType('MyEnum', {\n\t *  single: 'Coin',\n\t *  multi: 'vector<Coin>',\n\t *  empty: null\n\t * });\n\t *\n\t * console.log(\n\t *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }\n\t *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }\n\t * )\n\t *\n\t * // and serialization\n\t * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();\n\t * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });\n\t *\n\t * @param name\n\t * @param variants\n\t */\n\tpublic registerEnumType(typeName: TypeName, variants: EnumTypeDefinition): BCS {\n\t\t// When an Object is passed, we register it under a new key and store it\n\t\t// in the registered type system. This way we allow nested inline definitions.\n\t\tfor (let key in variants) {\n\t\t\tlet internalName = this.tempKey();\n\t\t\tlet value = variants[key];\n\n\t\t\tif (value !== null && !Array.isArray(value) && typeof value !== 'string') {\n\t\t\t\tvariants[key] = internalName;\n\t\t\t\tthis.registerStructType(internalName, value as StructTypeDefinition);\n\t\t\t}\n\t\t}\n\n\t\tlet struct = Object.freeze(variants); // Make sure the order doesn't get changed\n\n\t\t// IMPORTANT: enum is an ordered type and we have to preserve ordering in BCS\n\t\tlet canonicalOrder = Object.keys(struct);\n\n\t\t// Parse type parameters in advance to know the index of each generic parameter.\n\t\tlet { name, params: canonicalTypeParams } = this.parseTypeName(typeName);\n\n\t\treturn this.registerType(\n\t\t\ttypeName,\n\t\t\tfunction encodeEnum(\n\t\t\t\tthis: BCS,\n\t\t\t\twriter: BcsWriter,\n\t\t\t\tdata: { [key: string]: any | null },\n\t\t\t\ttypeParams,\n\t\t\t\ttypeMap,\n\t\t\t) {\n\t\t\t\tif (!data) {\n\t\t\t\t\tthrow new Error(`Unable to write enum \"${name}\", missing data.\\nReceived: \"${data}\"`);\n\t\t\t\t}\n\t\t\t\tif (typeof data !== 'object') {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Incorrect data passed into enum \"${name}\", expected object with properties: \"${canonicalOrder.join(\n\t\t\t\t\t\t\t' | ',\n\t\t\t\t\t\t)}\".\\nReceived: \"${JSON.stringify(data)}\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet key = Object.keys(data)[0];\n\t\t\t\tif (key === undefined) {\n\t\t\t\t\tthrow new Error(`Empty object passed as invariant of the enum \"${name}\"`);\n\t\t\t\t}\n\n\t\t\t\tlet orderByte = canonicalOrder.indexOf(key);\n\t\t\t\tif (orderByte === -1) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Unknown invariant of the enum \"${name}\", allowed values: \"${canonicalOrder.join(\n\t\t\t\t\t\t\t' | ',\n\t\t\t\t\t\t)}\"; received \"${key}\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tlet invariant = canonicalOrder[orderByte];\n\t\t\t\tlet invariantType = struct[invariant] as TypeName | null;\n\n\t\t\t\t// write order byte\n\t\t\t\twriter.write8(orderByte);\n\n\t\t\t\t// When { \"key\": null } - empty value for the invariant.\n\t\t\t\tif (invariantType === null) {\n\t\t\t\t\treturn writer;\n\t\t\t\t}\n\n\t\t\t\tlet paramIndex = canonicalTypeParams.indexOf(invariantType);\n\t\t\t\tlet typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n\n\t\t\t\t{\n\t\t\t\t\tlet { name, params } = this.parseTypeName(typeOrParam);\n\t\t\t\t\treturn this.getTypeInterface(name)._encodeRaw.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\twriter,\n\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\tparams,\n\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunction decodeEnum(this: BCS, reader: BcsReader, typeParams, typeMap) {\n\t\t\t\tlet orderByte = reader.readULEB();\n\t\t\t\tlet invariant = canonicalOrder[orderByte];\n\t\t\t\tlet invariantType = struct[invariant] as TypeName | null;\n\n\t\t\t\tif (orderByte === -1) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Decoding type mismatch, expected enum \"${name}\" invariant index, received \"${orderByte}\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Encode an empty value for the enum.\n\t\t\t\tif (invariantType === null) {\n\t\t\t\t\treturn { [invariant]: true };\n\t\t\t\t}\n\n\t\t\t\tlet paramIndex = canonicalTypeParams.indexOf(invariantType);\n\t\t\t\tlet typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n\n\t\t\t\t{\n\t\t\t\t\tlet { name, params } = this.parseTypeName(typeOrParam);\n\t\t\t\t\treturn {\n\t\t\t\t\t\t[invariant]: this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t}\n\t/**\n\t * Get a set of encoders/decoders for specific type.\n\t * Mainly used to define custom type de/serialization logic.\n\t *\n\t * @param type\n\t * @returns {TypeInterface}\n\t */\n\tpublic getTypeInterface(type: string): TypeInterface {\n\t\tlet typeInterface = this.types.get(type);\n\n\t\t// Special case - string means an alias.\n\t\t// Goes through the alias chain and tracks recursion.\n\t\tif (typeof typeInterface === 'string') {\n\t\t\tlet chain: string[] = [];\n\t\t\twhile (typeof typeInterface === 'string') {\n\t\t\t\tif (chain.includes(typeInterface)) {\n\t\t\t\t\tthrow new Error(`Recursive definition found: ${chain.join(' -> ')} -> ${typeInterface}`);\n\t\t\t\t}\n\t\t\t\tchain.push(typeInterface);\n\t\t\t\ttypeInterface = this.types.get(typeInterface);\n\t\t\t}\n\t\t}\n\n\t\tif (typeInterface === undefined) {\n\t\t\tthrow new Error(`Type ${type} is not registered`);\n\t\t}\n\n\t\treturn typeInterface;\n\t}\n\n\t/**\n\t * Parse a type name and get the type's generics.\n\t * @example\n\t * let { typeName, typeParams } = parseTypeName('Option<Coin<SUI>>');\n\t * // typeName: Option\n\t * // typeParams: [ 'Coin<SUI>' ]\n\t *\n\t * @param name Name of the type to process\n\t * @returns Object with typeName and typeParams listed as Array\n\t */\n\tpublic parseTypeName(name: TypeName): {\n\t\tname: string;\n\t\tparams: TypeName[];\n\t} {\n\t\tif (Array.isArray(name)) {\n\t\t\tlet [typeName, ...params] = name;\n\t\t\treturn { name: typeName, params };\n\t\t}\n\n\t\tif (typeof name !== 'string') {\n\t\t\tthrow new Error(`Illegal type passed as a name of the type: ${name}`);\n\t\t}\n\n\t\tlet [left, right] = this.schema.genericSeparators || ['<', '>'];\n\n\t\tlet l_bound = name.indexOf(left);\n\t\tlet r_bound = Array.from(name).reverse().indexOf(right);\n\n\t\t// if there are no generics - exit gracefully.\n\t\tif (l_bound === -1 && r_bound === -1) {\n\t\t\treturn { name: name, params: [] };\n\t\t}\n\n\t\t// if one of the bounds is not defined - throw an Error.\n\t\tif (l_bound === -1 || r_bound === -1) {\n\t\t\tthrow new Error(`Unclosed generic in name '${name}'`);\n\t\t}\n\n\t\tlet typeName = name.slice(0, l_bound);\n\t\tlet params = splitGenericParameters(\n\t\t\tname.slice(l_bound + 1, name.length - r_bound - 1),\n\t\t\tthis.schema.genericSeparators,\n\t\t);\n\n\t\treturn { name: typeName, params };\n\t}\n}\n\n/**\n * Register the base set of primitive and common types.\n * Is called in the `BCS` constructor automatically but can\n * be ignored if the `withPrimitives` argument is not set.\n */\nexport function registerPrimitives(bcs: BCS): void {\n\tbcs.registerType(\n\t\tBCS.U8,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write8(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read8();\n\t\t},\n\t\t(u8) => u8 < 256,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U16,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write16(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read16();\n\t\t},\n\t\t(u16) => u16 < 65536,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U32,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write32(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read32();\n\t\t},\n\t\t(u32) => u32 <= 4294967296n,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U64,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write64(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read64();\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U128,\n\t\tfunction (writer: BcsWriter, data: bigint) {\n\t\t\treturn writer.write128(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read128();\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U256,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write256(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read256();\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.BOOL,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write8(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read8().toString(10) === '1';\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.STRING,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(data), (writer, el) => writer.write8(el.charCodeAt(0)));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader\n\t\t\t\t.readVec((reader) => reader.read8())\n\t\t\t\t.map((el: bigint) => String.fromCharCode(Number(el)))\n\t\t\t\t.join('');\n\t\t},\n\t\t(_str: string) => true,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.HEX,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(fromHEX(data)), (writer, el) => writer.write8(el));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\tlet bytes = reader.readVec((reader) => reader.read8());\n\t\t\treturn toHEX(new Uint8Array(bytes));\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.BASE58,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(fromB58(data)), (writer, el) => writer.write8(el));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\tlet bytes = reader.readVec((reader) => reader.read8());\n\t\t\treturn toB58(new Uint8Array(bytes));\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.BASE64,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(fromB64(data)), (writer, el) => writer.write8(el));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\tlet bytes = reader.readVec((reader) => reader.read8());\n\t\t\treturn toB64(new Uint8Array(bytes));\n\t\t},\n\t);\n}\n\nexport function getRustConfig(): BcsConfig {\n\treturn {\n\t\tgenericSeparators: ['<', '>'],\n\t\tvectorType: 'Vec',\n\t\taddressLength: SUI_ADDRESS_LENGTH,\n\t\taddressEncoding: 'hex',\n\t};\n}\n\nexport function getSuiMoveConfig(): BcsConfig {\n\treturn {\n\t\tgenericSeparators: ['<', '>'],\n\t\tvectorType: 'vector',\n\t\taddressLength: SUI_ADDRESS_LENGTH,\n\t\taddressEncoding: 'hex',\n\t};\n}\n"],"names":["options","name","data","writer","reader","name","params","typeName","bcs"],"mappings":"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","debugId":null}}]
}